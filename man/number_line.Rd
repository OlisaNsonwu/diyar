% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/number_line.R
\name{number_line}
\alias{number_line}
\alias{as.number_line}
\alias{is.number_line}
\alias{reverse_number_line}
\alias{series}
\alias{shift_number_line}
\alias{expand_number_line}
\alias{compress_number_line}
\alias{unique.number_line}
\alias{format.number_line}
\title{Number lines}
\usage{
number_line(a, z, id = NULL)

as.number_line(x)

is.number_line(x)

reverse_number_line(x, direction = "both")

series(x, by = 1)

shift_number_line(x, by = 1)

expand_number_line(x, by = 1, point = "both")

compress_number_line(..., method = c("across", "chain", "aligns_start",
  "aligns_end", "inbetween"), deduplicate = TRUE)

\method{unique}{number_line}(x, ...)

\method{format}{number_line}(x, ...)
}
\arguments{
\item{a}{Start of the number line. Should be, or can be coerced to a \code{numeric} object}

\item{z}{End of the number line. Should be, or can be coerced to a \code{numeric} object}

\item{id}{Unique \code{numeric} element ID}

\item{x}{\code{number_line} object}

\item{direction}{Type of \code{"number_line"} objects whose start and end points are to be reversed. Options are; \code{"increasing"}, \code{"decreasing"} or \code{"both"}.}

\item{by}{increment or decrement}

\item{...}{arguments for particular methods | \code{number_line} objects in \code{compress_number_line()}}

\item{deduplicate}{\code{TRUE} to retain only one of the overlaping \code{number_line} objects}
}
\value{
\code{number_line} object

\code{logical} object
}
\description{
A set of functions to create and manipulate \code{number_line} objects.
}
\details{
A \code{number_line} object represents a series of real numbers on a number line.

Visually, it's presented as the start and end point of the series.

The \code{direction} of the number line indicates if it's an \code{"increasing"} or \code{"decreasing"} series of real numbers.
An \code{"increasing"} direction is when the start point is less than the end point and vice versa.

\code{reverse_number_line()} - reverses the direction of a number line. A reversed \code{number_line} object has its start and end points swapped but maintains the same width or length.
The \code{direction} argument determines which type of number lines will be reversed.
\code{number_line} objects with non-finite numeric starts or end points i.e. (\code{NA}, \code{NaN} and \code{Inf}) can't be reversed.

\code{series()} - a convenience function to convert the \code{number_line} object to a sequence of real numbers. The sequence will also include the start and end points.
The direction of the sequence will correspond to that of the \code{number_line} object.

\code{shift_number_line()} - a convenience function to shift a \code{number_line} object towards the positive or negative end of the number line.

\code{expand_number_line()} - a convenience function to increase or decrease the width or length of a  \code{number_line} object.

\code{compress_number_line()} - Collapse overlaping \code{number_line} objects into a new \code{number_line} objects that covers the start and end points of the originals.
This results in the duplicate \code{number_line} objects having new but identiical start and end points which are those of the expanded number line.
See \code{\link{overlap}} for further details on overlaping \code{number_line} objects.
If a familiar (but unique) \code{id} is used when creating the \code{number_line} objects,
\code{compress_number_line()} can be a simple alternative to \code{\link{record_group}} or \code{\link{episode_group}}.
}
\examples{
library(lubridate)

number_line(-100, 100)
number_line(10, 11.2)

# other numeric based object classes are also compatible for numeric_line objects
number_line(dmy("12/03/2019"), dmy("05/01/2019"))
number_line(dmy_hms("15/05/2019 13:15:07"), dmy_hms("15/05/2019 15:17:10"))

# a prompt is given if 'a' and 'z' have different classes. Consider if these need to be corrected
number_line(2, dmy("05/01/2019"))
number_line(dmy("05/01/2019"), 2)

# convert numeric objects to number_line objects
as.number_line(5.1)
as.number_line(dmy("21/10/2019"))

# test for number_line objects
a <- number_line(0, -100)
b <- number_line(dmy("25/04/2019"), dmy("01/01/2019"))
is.number_line(a)
is.number_line(b)

#reverse number_line objects
reverse_number_line(number_line(dmy("25/04/2019"), dmy("01/01/2019")))
reverse_number_line(number_line(200,-100), "increasing")
reverse_number_line(number_line(200,-100), "decreasing")

# Convert a number line object to its series of real numbers
series(number_line(1, 5))
series(number_line(5, 1), .5)
series(number_line(dmy("01/04/2019"), dmy("10/04/2019")), 1)

# The length of the vector depends on the object class
series(number_line(dmy("01/04/2019"), dmy("04/04/2019")), 1.5)
series(number_line(dmy_hms("01/04/2019 00:00:00"), dmy_hms("04/04/2019 00:00:00")), 1.5)
series(number_line(dmy_hms("01/04/2019 00:00:00"), dmy_hms("04/04/2019 00:00:00")), duration(1.5,"days"))

# Shift \\code{number_line} objects
number_line(5,6)
# Towards the positive end of the number line
shift_number_line(number_line(5,6), 2)
# Towards the negative end of the number line
shift_number_line(number_line(6,1), -2)

# Increase or reduce the width or length of a \\code{number_line} object
c(number_line(3,6), number_line(6,3))
expand_number_line(c(number_line(3,6), number_line(6,3)), 2)
expand_number_line(c(number_line(3,6), number_line(6,3)), -1)
expand_number_line(c(number_line(3,6), number_line(6,3)), 2, "start")
expand_number_line(c(number_line(3,6), number_line(6,3)), -2, "end")

# collapse number lines
c(number_line(1,5), number_line(2,4), number_line(10,10))
compress_number_line(c(number_line(1,5), number_line(2,4), number_line(10,10)))

c(number_line(10,10), number_line(10,20), number_line(5,30),  number_line(30,40))
compress_number_line(number_line(10,10), number_line(10,20), number_line(5,30), number_line(30,40))
compress_number_line(number_line(10,10), number_line(10,20), number_line(5,30), number_line(30,40), method = "inbetween")
compress_number_line(number_line(10,10), number_line(10,20), number_line(5,30), number_line(30,40), method = "chain")
compress_number_line(number_line(10,10), number_line(10,20), number_line(5,30), number_line(30,40), method = "across")

}
