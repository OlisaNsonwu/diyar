% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/episode_group.R
\name{episodes}
\alias{episodes}
\alias{episodes_wf_splits}
\alias{fixed_episodes}
\alias{rolling_episodes}
\alias{episode_group}
\title{Link events  to chronological episodes.}
\usage{
episodes(
  date,
  case_length = Inf,
  episode_type = "fixed",
  recurrence_length = case_length,
  episode_unit = "days",
  strata = NULL,
  sn = NULL,
  episodes_max = Inf,
  rolls_max = Inf,
  case_overlap_methods = "overlap",
  recurrence_overlap_methods = case_overlap_methods,
  skip_if_b4_lengths = FALSE,
  data_source = NULL,
  data_links = "ANY",
  custom_sort = NULL,
  skip_order = Inf,
  reference_event = "last_record",
  case_for_recurrence = FALSE,
  from_last = FALSE,
  group_stats = FALSE,
  display = "none",
  case_sub_criteria = NULL,
  recurrence_sub_criteria = case_sub_criteria,
  case_length_total = 1,
  recurrence_length_total = case_length_total
)

episodes_wf_splits(
  date,
  case_length = Inf,
  episode_type = "fixed",
  recurrence_length = case_length,
  episode_unit = "days",
  strata = NULL,
  sn = NULL,
  episodes_max = Inf,
  rolls_max = Inf,
  case_overlap_methods = "overlap",
  recurrence_overlap_methods = case_overlap_methods,
  skip_if_b4_lengths = FALSE,
  data_source = NULL,
  data_links = "ANY",
  custom_sort = NULL,
  skip_order = Inf,
  reference_event = "last_record",
  case_for_recurrence = FALSE,
  from_last = FALSE,
  group_stats = FALSE,
  display = "none",
  case_sub_criteria = NULL,
  recurrence_sub_criteria = case_sub_criteria,
  case_length_total = 1,
  recurrence_length_total = case_length_total
)

fixed_episodes(
  date,
  case_length = Inf,
  episode_unit = "days",
  to_s4 = TRUE,
  case_overlap_methods = "overlap",
  deduplicate = FALSE,
  display = "none",
  bi_direction = FALSE,
  recurrence_length = case_length,
  recurrence_overlap_methods = case_overlap_methods,
  include_index_period = TRUE,
  ...,
  overlap_methods = "overlap",
  overlap_method = "overlap",
  x
)

rolling_episodes(
  date,
  case_length = Inf,
  recurrence_length = case_length,
  episode_unit = "days",
  to_s4 = TRUE,
  case_overlap_methods = "overlap",
  recurrence_overlap_methods = case_overlap_methods,
  deduplicate = FALSE,
  display = "none",
  bi_direction = FALSE,
  include_index_period = TRUE,
  ...,
  overlap_methods = "overlap",
  overlap_method = "overlap",
  x
)

episode_group(df, ..., episode_type = "fixed")
}
\arguments{
\item{date}{Event date (\code{date}, \code{datetime} or \code{numeric}) or period (\code{\link{number_line}}).}

\item{case_length}{Cut-off point (\code{numeric}) or period (\code{\link{number_line}}), distinguishing one \code{"case"} from another.
This is the case window.}

\item{episode_type}{\code{"fixed"}, \code{"rolling"} or \code{"recursive"}. See \code{Details}.}

\item{recurrence_length}{Cut-off point or period distinguishing a \code{"recurrent"} event from its index event.
This is the recurrence window. By default, it's the same as \code{case_length}.}

\item{episode_unit}{Time units for \code{case_length} and \code{recurrence_length}. Options are "seconds", "minutes", "hours", "days", "weeks", "months" or "years". See \code{diyar::episode_unit}.}

\item{strata}{Subsets of the dataset. Episodes are created separately for each \code{strata}. Assigning \code{NA} to \code{strata} will exclude that record from episode tracking.}

\item{sn}{Unique numerical record identifier. Useful for creating familiar episode identifiers.}

\item{episodes_max}{The maximum number of episodes permitted within each \code{strata}.}

\item{rolls_max}{Maximum number of times the index \code{"case"} can recur. Only used if \code{episode_type} is \code{"rolling"}.}

\item{case_overlap_methods}{Methods of overlap considered when tracking duplicates of \code{"case"} events. See (\code{\link{overlaps}})}

\item{recurrence_overlap_methods}{Methods of overlap considered when tracking duplicates of \code{"recurrent"} events. See (\code{\link{overlaps}})}

\item{skip_if_b4_lengths}{If \code{TRUE} (default), \code{events} before the cut-off points or periods, or not captured by \code{"case_sub_criteria"} or \code{"recurrence_sub_criteria"} are skipped.}

\item{data_source}{Unique data source identifier. Useful when the dataset has data from multiple sources.}

\item{data_links}{A set of \code{data_sources} required in each episode. An \code{episode} without records from these \code{data_sources} will be skipped or unlinked. See \code{Details}.}

\item{custom_sort}{Preferential order for selecting index (\code{"case"}) events.}

\item{skip_order}{\code{"nth"} level of \code{custom_sort}. Episodes with index events beyond this level of preference are skipped.}

\item{reference_event}{If \code{TRUE} (default), the reference event for a \code{recurrence window} will be the last event from the previous window.
If \code{FALSE} (default), it will be the first event. Only used if \code{episode_type} is \code{"rolling"}.}

\item{case_for_recurrence}{If \code{TRUE}, both \code{"case"} and \code{"recurrent"} events will have a case window.
If \code{FALSE} (default), only \code{case events} will have a \code{case window}. Only used if \code{episode_type} is \code{"rolling"}.}

\item{from_last}{Chronological order for episode tracking i.e. ascending (\code{TRUE}) or descending (\code{FALSE}).}

\item{group_stats}{If \code{TRUE} (default), episode-specific information like episode start and endpoints are returned.}

\item{display}{The messages printed on screen. Options are; \code{"none"} (default) or, \code{"progress"} and \code{"stats"} for a progress update or a more detailed breakdown of the tracking process.}

\item{case_sub_criteria}{Matching conditions for "case" windows in addition to temporal links. Supplied as a \code{\link{sub_criteria}} object.}

\item{recurrence_sub_criteria}{Matching conditions for "recurrence" windows in addition to temporal links. Supplied as a \code{\link{sub_criteria}} object.}

\item{case_length_total}{Minimum number of matched case windows required for an episode. See details}

\item{recurrence_length_total}{Minimum number of matched recurrence windows required for an episode. See details}

\item{to_s4}{If \code{TRUE}, output is an \code{\link[=epid-class]{epid}} object. If \code{FALSE}, it's a  or \code{data.frame}.}

\item{deduplicate}{If \code{TRUE}, \code{"duplicate"} events are excluded from the output.}

\item{bi_direction}{If \code{TRUE}, \code{"duplicate"} events before and after the index event are tracked.}

\item{include_index_period}{If \code{TRUE}, events overlapping with the index event or period are linked even if they are outside the cut-off period.}

\item{...}{Arguments passed to \bold{\code{episodes}}}

\item{overlap_methods}{Deprecated. Please use \code{case_overlap_methods} or \code{recurrence_overlap_methods}. Methods of overlap considered when tracking duplicate event. See (\code{\link{overlaps}})}

\item{overlap_method}{Deprecated. Please use \code{case_overlap_methods} or \code{recurrence_overlap_methods}. Methods of overlap considered when tracking event. All event are checked by the same set of \code{overlap_method}.}

\item{x}{Deprecated. Record date or period. Please use \code{date}}

\item{df}{\code{data.frame}. One or more datasets appended together. See \code{Details}.}
}
\value{


\code{\link[=epid-class]{epid}} or \code{list} (\code{\link[=epid-class]{epid}} and \code{ggplot}) object
}
\description{
Link events with matching attributes and within specified durations of each other.
Records in each episode are assigned a unique identifier with relevant group-level information.
}
\details{
All dated records within a specified duration of an index record are linked together as an episodes.
By default, this process occurs in ascending order, beginning with the earliest event.
However, this can be changed to a descending (\code{from_last}) or custom order \code{custom_sort}.
Ties are always broken by the chronological order of events.

A \code{"fixed"} episode has a fixed maximum duration determined by \code{case_length}, while a \code{"rolling"} episode can continue to recur.
A \code{"rolling"} episode will persist as long as is specified by \code{rolls_max}.

\bold{\code{episodes()}} will categorise records into 5 type of events;

\itemize{
\item \code{"Case"} - Index case of the episode.
\item \code{"Duplicate_C"} - Duplicate of the index case.
\item \code{"Recurrent"} - Recurrence of the index case.
\item \code{"Duplicate_R"} - Duplicate of the recurrent event.
\item \code{"Skipped"} - Records excluded from the episode tracking process.
}

\code{data_links} should be a \code{list} of \code{atomic} vectors with every element named \code{"l"} (links) or \code{"g"} (groups).
\itemize{
\item if named \code{"l"}, only \code{episodes} with records from every listed \code{data_source} will be retained.
\item if named \code{"g"}, only \code{episodes} with records from any listed \code{data_source} will be retained.
}

\bold{\code{episode_group()}} as it existed before \code{v0.2.0} has been retired.
It now exists to support previous code with minimal disruption.
Please use \bold{\code{episodes()}} for new scripts.

\bold{\code{rolling_episodes()}} and \bold{\code{rolling_episodes()}} are wrapper functions for tracking \code{"fixed"} and \code{"rolling"} episodes respectively.
They exist for convenience and to support previous code with minimal disruption.
Please consider using \bold{\code{episodes()}} for new scripts.

See \code{vignette("episodes")} for more information.
}
\examples{
library(diyar)
data(infections)
data(hospital_admissions)

db_1 <- infections
db_1$patient_id <- c(rep("PID 1",8), rep("PID 2",3))

# Fixed episodes
# One 16-day (15-day difference) episode per patient
db_1$epids_p <- episodes(date = db_1$date,
                         strata = db_1$patient_id,
                         case_length = 15,
                         episodes_max = 1)
# Rolling episodes
# 16-day episodes with recurrence periods of 11 days
db_1$rd_b <- episodes(date = db_1$date,
                     case_length = 15,
                     recurrence_length = 10,
                     episode_type = "rolling")

# Interval grouping
hospital_admissions$admin_period <- number_line(hospital_admissions$admin_dt,
                                                hospital_admissions$discharge_dt)
admissions <- hospital_admissions[c("admin_period","epi_len")]

# Episodes of overlapping periods of admission
hospital_admissions$epids_i<- episodes(date = hospital_admissions$admin_period,
                                       case_length = 0,
                                       case_overlap_methods = "inbetween")

}
\seealso{
\code{\link{custom_sort}}, \code{\link{sub_criteria}}, \code{\link[=windows]{epid_length}}, \code{\link[=windows]{epid_window}}, \code{\link{partitions}}, \code{\link{links}}, \code{\link{overlaps}} and \code{\link{number_line}}
}
