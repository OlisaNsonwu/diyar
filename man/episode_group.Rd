% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/episode_group.R
\name{episode_group}
\alias{episode_group}
\title{Episode grouping for case definitions}
\usage{
episode_group(df, sn = NULL, strata = NULL, date, case_length,
  episode_type = "fixed", episode_unit = "days", episodes_max = Inf,
  recurrence_length = NULL, rolls_max = Inf, data_source = NULL,
  custom_sort = NULL, from_last = FALSE, overlap_method = "none",
  bi_direction = FALSE, group_stats = FALSE, display = TRUE)
}
\arguments{
\item{df}{Dataframe. One or more datasets appended together.}

\item{sn}{\code{numeric} unique record indentifier for the dataframe.}

\item{strata}{Column names. Episodes will be unique to each strata. See \code{\link{record_group}}.}

\item{date}{Record date. \code{date}, \code{datetime} or \code{\link[lubridate]{interval}} objects.}

\item{case_length}{Duration from the \code{"Case"} within which another record of the same \code{strata} will be considered a \code{"Duplicate"}.}

\item{episode_type}{\emph{"fixed"} or \emph{"rolling"}.}

\item{episode_unit}{Time units not less than "seconds" and supported by \code{\link[lubridate]{duration}}}

\item{episodes_max}{Maximum number times to group episodes in each strata.}

\item{recurrence_length}{Duration from the last record of an episode within which another record of the same \code{strata} will be considered a \code{"Recurrent"} record.}

\item{rolls_max}{Maximum number of recurrence periods permitted within each episode. Only used if \code{episode_type} is \emph{"rolling"}.}

\item{data_source}{Unique dataset indentifier for the dataframe. Useful when dataframe contains multiple datsets.}

\item{custom_sort}{If \code{TRUE}, \emph{"Case"} assignment will be in preference to this sort order. Useful in specifying that episode grouping begins at a particular kind of record regardless of chronological order.}

\item{from_last}{If \code{TRUE}, episode grouping will be backwards in time - starting at the most recent record and proceeding to the earliest. If \code{FALSE}, it'll be forward in time - starting at the earliest record and proceeding to the most recent.}

\item{overlap_method}{A set of options by which grouped intervals should overlap. Options are; \emph{"none"} (default), \emph{"overlap"}, \emph{"aligns_start"}, \emph{"aligns_end"}, \emph{"within"} and \emph{"chain"}}

\item{bi_direction}{If \code{FALSE}, \emph{"Duplicate"} records are those within the \code{case_length} and \code{recurrence_length} before or after the \emph{"Case"} as determined by \code{from_last}. If \code{TRUE}, \emph{"Duplicate"} records are those on either side of the \emph{"Case"}.}

\item{group_stats}{If \code{TRUE}, output will include additional columns with useful stats for each episode.}

\item{display}{If \code{TRUE}, status messages are not printed on screen.}
}
\value{
Dataframe

\itemize{
\item \code{sn} - the unique record identifier provided
\item \code{epid} - unique episode indentifier
\item \code{case_nm} - record type in regards to case assignment
\item \code{epid_dataset} - datasets contained in each episode
\item \code{epid_interval} - lubridate \code{interval} object. Episode start and end dates
\item \code{epid_length} - \code{difftime} object. Difference between episode start and end dates. Unit for will match that supplied as \code{episode_unit}
\item \code{epid_total} - number of records in each record group
}
}
\description{
This function assigns records into unique chronological episodes
}
\details{
Episode grouping begins at a reference record (\emph{"Case"}) and proceeds forward or backward in time depending on \code{from_last}.
If \code{custom_sort} is used, episode grouping can be forced to begin at certain record before proceeding forward or backwards in time.
The maximun duration of a \emph{"fixed"} episode is the \code{case_length} while, the maximum duration of a \emph{"rolling"} episode is the
\code{case_length} in addition to all recurrence periods. A recurrence period is the \code{recurrence_length} from the last record in an episode
}
\examples{

library(lubridate)
library(dplyr)

data <- data.frame(date = seq.Date(dmy("01/04/2018"), dmy("31/05/2018"), by="6 days"))
data$epi_len <- 15
data <- mutate(data, rd_id = row_number())

# Begin episode grouping at the earliest record thereby making it the "Case"
cbind(data,
      episode_group(data, sn=rd_id, date = date, case_length = epi_len)
      )

# Begin episode grouping at the most recent record thereby making it the "Case"
cbind(data,
      episode_group(data, rd_id, date=date, case_length = epi_len, from_last = TRUE, display = FALSE)
      )

# Create rolling episodes
data$recur <- 30
cbind(data,
      episode_group(data, rd_id, date=date, case_length = epi_len, episode_type = "rolling",
                    recurrence_length = recur, display = FALSE)
      )

# Limit the amount of possible recurrence period
cbind(data,
      episode_group(data, rd_id, date=date, case_length = epi_len, episode_type = "rolling",
                    recurrence_length = recur, rolls_max = 1, display = FALSE)
      )

# Limit the number of times episode grouping occurs
cbind(data,
      episode_group(data, rd_id, date=date, case_length = epi_len, episode_type = "fixed",
                    recurrence_length = recur, episodes_max = 1, from_last = FALSE, display = FALSE)
      )

# User defined case assignment
data$infection <- c("BSI", rep("UTI",2), "UTI", "BSI",  "UTI", rep("BSI",2), "RTI","RTI","BSI")

  # When there is a combination with UTI, BSI and RTI records within the same case or recurrence length, preference for case assignment is UTI > BSI > RTI
data$infection <- factor(data$infection, levels = c("UTI","BSI","RTI"))

  # Different type of records can have different case or recurrence lengths
data <- mutate(data,
               epi_len = case_when(
                 infection == "BSI" ~ 14,
                 infection == "UTI" ~ 30,
                 infection == "RTI" ~ 60
                 )
               )

cbind(data,
      episode_group(data, rd_id, date=date, case_length = epi_len,
                    recurrence_length = recur, custom_sort = infection, group_stats = TRUE, from_last = FALSE, display = FALSE)
      )

  # Can make it such that, only when the combination includes BSI records should preference go to the BSI record
  # When it's a combination without a "BSI" record, preference for case assignment reverts back to the earliest or most recent record depending on from_last
data$infection_ord <- ifelse(data$infection =="BTI",0,1)

cbind(data,
      episode_group(data, rd_id, date=date, case_length = epi_len,
                    custom_sort = infection_ord, group_stats = TRUE, from_last = FALSE, bi_direction = TRUE, display = FALSE)
)

  #Can make it such that, duplicates on either side of the case are grouped into the same episode
data$infection_ord <- ifelse(data$infection =="RTI",0,1)

cbind(data,
      episode_group(data, rd_id, date=date, case_length = epi_len,
                   custom_sort = infection_ord, group_stats = TRUE, from_last = FALSE, bi_direction = TRUE, display = FALSE)
      )

data$infection_ord <- ifelse(data$infection =="UTI",0,1)

cbind(data,
      episode_group(data, rd_id, date=date, case_length = epi_len, episodes_max = 1,
                    custom_sort = infection_ord, group_stats = TRUE, from_last = FALSE, bi_direction = TRUE, display = FALSE)
      )

# Stratified episode grouping
data$patient_id <- c(rep("PID 1",8), rep("PID 2",3))
cbind(data,
      episode_group(data, rd_id, date=date, strata = patient_id, case_length = epi_len,
                    recurrence_length = recur, episodes_max = 1, from_last = FALSE, display = FALSE)
      )

cbind(data,
      episode_group(data, rd_id, date=date, strata = c(patient_id, infection), case_length = epi_len,
                    recurrence_length = recur, episodes_max = 1, from_last = FALSE, display = FALSE)
      )

# data_source is useful when grouping episodes across multiple datasets or as diagnostic option
cbind(data,
      episode_group(data, rd_id, date=date, case_length = epi_len, episode_type = "fixed",
                    recurrence_length = recur, episodes_max = 1, data_source = infection, from_last = FALSE, display = FALSE)
)

cbind(data,
      episode_group(data, rd_id, date=date, case_length = epi_len, episode_type = "fixed",
                    recurrence_length = recur, episodes_max = 1, data_source = c(patient_id, infection), display = FALSE)
)

}
\seealso{
\code{\link{record_group}}
}
