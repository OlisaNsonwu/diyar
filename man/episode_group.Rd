% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/episode_group.R
\name{episode_group}
\alias{episode_group}
\alias{fixed_episodes}
\alias{rolling_episodes}
\title{Episode grouping for case definitions and record deduplication}
\usage{
episode_group(df, sn = NULL, strata = NULL, date, case_length,
  episode_type = "fixed", episode_unit = "days", episodes_max = Inf,
  recurrence_length = NULL, rolls_max = Inf, data_source = NULL,
  custom_sort = NULL, from_last = FALSE, overlap_method = c("exact",
  "across", "inbetween", "aligns_start", "aligns_end", "chain"),
  overlap_methods = NULL, bi_direction = FALSE, group_stats = FALSE,
  display = TRUE, deduplicate = FALSE, to_s4 = TRUE,
  recurrence_from_last = TRUE, case_for_recurrence = FALSE)

fixed_episodes(date, sn = NULL, strata = NULL, case_length,
  episode_unit = "days", episodes_max = Inf, data_source = NULL,
  custom_sort = NULL, from_last = FALSE, overlap_method = c("exact",
  "across", "inbetween", "aligns_start", "aligns_end", "chain"),
  overlap_methods = "exact|across|chain|aligns_start|aligns_end|inbetween",
  bi_direction = FALSE, group_stats = FALSE, display = TRUE,
  deduplicate = FALSE, x, to_s4 = TRUE)

rolling_episodes(date, sn = NULL, strata = NULL, case_length,
  recurrence_length = NULL, episode_unit = "days",
  episodes_max = Inf, rolls_max = Inf, data_source = NULL,
  custom_sort = NULL, from_last = FALSE, overlap_method = c("exact",
  "across", "inbetween", "aligns_start", "aligns_end", "chain"),
  overlap_methods = "exact|across|chain|aligns_start|aligns_end|inbetween",
  bi_direction = FALSE, group_stats = FALSE, display = TRUE,
  deduplicate = FALSE, x, to_s4 = TRUE, recurrence_from_last = TRUE,
  case_for_recurrence = FALSE)
}
\arguments{
\item{df}{\code{data.frame}. One or more datasets appended together.}

\item{sn}{Unique numerical record identifier. Optional.}

\item{strata}{Subsets of the dataset within which episode grouping will be done separately. In \code{\link{episode_group}}, you can use multiple columns supplied as column names. \code{\link{record_group}} can create useful \code{strata}.}

\item{date}{Date (\code{date}, \code{datetime} or \code{numeric}) or period (\code{\link{number_line}}) of events.}

\item{case_length}{Duration after a \code{"case"} within which subsequent events are considred \code{duplicate} events. This period is refered to as the the \code{case window}.}

\item{episode_type}{\code{"fixed"} or \code{"rolling"}.}

\item{episode_unit}{Time units. Options are "seconds", "minutes", "hours", "days", "weeks", "months" or "years".}

\item{episodes_max}{Maximum number of times to group episodes within each \code{strata}.}

\item{recurrence_length}{Duration after the last or first event (see \code{recurrence_from_last}) of the previous window within which subsequent events are considered \code{"recurrent"} events. This period refered to as the \code{recurrence window}. If \code{recurrence_length} is not supplied, \code{case_length} is used as the \code{recurrence_length}.}

\item{rolls_max}{Maximum number of times an event can reoccur within an episode. Only used if \code{episode_type} is \code{"rolling"}.}

\item{data_source}{Unique dataset identifier. Useful when the dataset contains data from multiple sources. In \code{\link{episode_group}}, you can use multiple columns supplied as column names.}

\item{custom_sort}{If \code{TRUE}, \code{"case"} assignment will be done with preference to this sort order. Useful in specifying that episode grouping begins at particular events regardless of chronological order. In \code{\link{episode_group}}, you can use multiple columns as sort levels.}

\item{from_last}{If \code{TRUE}, episode grouping will be backwards in time - starting at the most recent event and proceeding to the earliest. If \code{FALSE}, it'll be forward in time - starting at the earliest event and proceeding to the most recent one.}

\item{overlap_method}{Method of overlap considered when grouping periods of events. Each pair of periods are checked with the same set of \code{overlap_method}. Deprecated use \code{overlap_methods} instead.}

\item{overlap_methods}{Methods of overlap considered when grouping intervals. Different pairs of periods can be checked with different sets \code{overlap_methods}}

\item{bi_direction}{If \code{FALSE}, \code{"duplicate"} events will be those within the \code{case_length} period, before or after the \code{"case"} as determined by \code{from_last}. If \code{TRUE}, \code{"duplicate"} events will be those within the same period before and after the \code{"case"}.}

\item{group_stats}{If \code{TRUE}, the output will include additional information with useful stats for each episode group.}

\item{display}{If \code{TRUE}, status messages are printed on screen.}

\item{deduplicate}{if \code{TRUE}, \code{"dupilcate"} records are excluded from the output.}

\item{to_s4}{if \code{TRUE}, changes the returned output to an \code{\link[=epid-class]{epid}} object.}

\item{recurrence_from_last}{if \code{TRUE}, the reference event for a \code{recurrence window} will be the last event from the previous \code{window}. If \code{FALSE} (default), it will be from the first event. Only used if \code{episode_type} is \code{"rolling"}.}

\item{case_for_recurrence}{if \code{TRUE}, both case and recurrence events will have a \code{case window}. If \code{FALSE} (default), only \code{case events} will have a \code{case window}. Only used if \code{episode_type} is \code{"rolling"}.}

\item{x}{Record date or interval. Deprecated. Please use \code{date}}
}
\value{


\code{\link[=epid-class]{epid}} objects or \code{data.frame} if \code{to_s4} is \code{FALSE})

\itemize{
\item \code{sn} - unique record identifier as provided
\item \code{epid | .Data} - unique episode identifier
\item \code{window} - unique window identifier
\item \code{case_nm} - record type in regards to case assignment
\item \code{epid_dataset} - data sources in each episode
\item \code{epid_interval} - episode start and end dates. A \code{\link{number_line}} object.
\item \code{epid_length} - difference between episode start and end dates (\code{difftime}). If possible, it's the same unit as \code{episode_unit} otherwise, a difference in days is returned
\item \code{epid_total} - number of records in each episode
}
}
\description{
Group events into chronological episodes
}
\details{
Episode grouping begins at a reference event (\code{"case"}) and proceeds forward or backward in time depending on \code{from_last}.
If \code{custom_sort} is used, episode grouping can be forced to begin at certain events before proceeding forward or backwards in time.
The maximum duration of a \code{"fixed"} episode is the \code{case_length}. This period is refered to as the \code{case window}. The maximum duration of a \code{"rolling"} episode is the
\code{case_length} plus all recurrence periods. The recurrence periods are refered to as \code{recurrence windows}. This is a specified duration (\code{recurrence_length}) after the last or first (depending on \code{recurrence_from_last}) event from the pervious window. Events within this period are considered \code{"recurrent"} events.

When a \code{data_source} identifier is provided,
\code{epid_dataset} is included in the output. This has the source of every event in each episode.

\code{fixed_episodes()} and \code{rolling_episodes()} are wrapper functions of \code{episode_group()}.
They are convenient alternatives with the same functionalities.
}
\examples{
library(dplyr)
library(lubridate)

#1. Fixed episodes
data(infections); infections
db_1 <- infections
# 16-day (difference of 15 days) episodes beginning from the earliest record
db_1$fd <- fixed_episodes(db_1$date, case_length = 15, display = FALSE)
# 16-hour (difference of 15 hours) episodes beginning from the earliest record
db_1$fh <- fixed_episodes(db_1$date, case_length = 15,
episode_unit = "hours", display = FALSE)
db_1

#2. Rolling episodes
# Case length and recurrence periods of 16 days
db_1$rd_a <- rolling_episodes(db_1$date, case_length = 15, display = FALSE)
# Case length of 16 days and recurrence periods of 11 days
db_1$rd_b <- rolling_episodes(db_1$date, case_length = 15,
recurrence_length = 10, display = FALSE)
# Case length of 16 days and 2 recurrence periods of 11 days
db_1$rd_c <- rolling_episodes(db_1$date, case_length = 15,
recurrence_length = 10, rolls_max = 2, display = FALSE)
db_1

# 3. Stratified episode grouping
db_3 <- infections

db_3$patient_id <- c(rep("PID 1",8), rep("PID 2",3))
# One 16-day episode per patient
db_3$epids_p <- fixed_episodes(date=db_3$date, strata = db_3$patient_id,
case_length = 15, episodes_max = 1, display = FALSE)
db_3

# 4. Case assignment
db_4 <- infections

## 4.1 Chronological order
db_4$forward_time <- fixed_episodes(db_4$date, case_length = 1,
episode_unit = "months", display = FALSE)
db_4$backward_time <- fixed_episodes(db_4$date, case_length = 1,
episode_unit = "months", from_last = TRUE, display = FALSE)
db_4

## 4.2 User defined order
db_4b <- infections
db_4b
# RTI > UTI, or RTI > BSI
db_4b$ord1 <- ifelse(db_4b$infection =="RTI",0,1)
# UTI > BSI > RTI
db_4b$ord2 <- factor(db_4b$infection, levels = c("UTI","BSI","RTI"))

db_4b$epids_1 <- fixed_episodes(db_4b$date, case_length = 15,
custom_sort = db_4b$ord1, display = FALSE)
db_4b$epids_2 <- fixed_episodes(db_4b$date, case_length = 15,
custom_sort = db_4b$ord2, display = FALSE)
db_4b$epids_2b <- fixed_episodes(db_4b$date, case_length = 15,
custom_sort = db_4b$ord2, bi_direction = TRUE, display = FALSE)
db_4b

#5. Interval grouping
data(hospital_admissions)

hospital_admissions$admin_period <- number_line(hospital_admissions$admin_dt,
hospital_admissions$discharge_dt)
admissions <- hospital_admissions[c("admin_period","epi_len")]
admissions

# Episodes of overlaping periods of admission
admissions$epi_0 <- fixed_episodes(date=admissions$admin_period, case_length = 0,
group_stats = TRUE, to_s4=TRUE)
admissions

# Overlaping periods of admission seperated by 1 month
admissions$epi_1 <- fixed_episodes(date=admissions$admin_period, case_length = 1,
episode_unit = "months", group_stats = TRUE, display = FALSE)
admissions

# Episodes of chained admission periods, and those with aligned end periods
admissions$epi_0b <- fixed_episodes(date=admissions$admin_period, case_length = 0,
overlap_methods = c("chain|aligns_end"), group_stats = TRUE, display = FALSE)
admissions["epi_0b"]


# Note - episode_group() takes column names not actual values
db_5 <- infections

db_5$recur <- 20
db_5$epids_f <- episode_group(db_5, date=date, episode_type = "fixed",
case_length = epi_len, display = FALSE)
db_5$epids_r <- episode_group(db_5, date=date, episode_type = "rolling",
case_length = epi_len, recurrence_length = recur, display = FALSE)
db_5

}
\seealso{
\code{\link{record_group}}, \code{\link{overlap}} and \code{\link{number_line}}
}
