% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/episode_group.R
\name{episode_group}
\alias{episode_group}
\title{Episode grouping for case definitions}
\usage{
episode_group(df, sn = NULL, strata = NULL, date, case_length,
  episode_type = "fixed", episode_unit = "days", episodes_max = Inf,
  recurrence_length = NULL, rolls_max = Inf, data_source = NULL,
  custom_sort = NULL, from_last = FALSE, overlap_method = "none",
  bi_direction = FALSE, group_stats = FALSE, display = TRUE)
}
\arguments{
\item{df}{Dataframe. One or more datasets appended together.}

\item{sn}{\code{numeric} unique record indentifier for the dataframe.}

\item{strata}{Column names. Episodes will be unique to each strata. See \code{\link{record_group}}.}

\item{date}{Record date. \code{date}, \code{datetime} or \code{\link[lubridate]{interval}} objects.}

\item{case_length}{Duration from the \code{"Case"} within which another record of the same \code{strata} will be considered a \code{"Duplicate"}.}

\item{episode_type}{\code{"fixed"} or \code{"rolling"}.}

\item{episode_unit}{Time units not less than "seconds" and supported by \code{\link[lubridate]{duration}}}

\item{episodes_max}{Maximum number times to group episodes in each strata.}

\item{recurrence_length}{Duration from the last record of an episode within which another record of the same \code{strata} will be considered a \code{"Recurrent"} record.}

\item{rolls_max}{Maximum number of recurrence periods permitted within each episode. Only used if \code{episode_type} is \code{"rolling"}.}

\item{data_source}{Unique dataset indentifier for the dataframe. Useful when dataframe contains multiple datsets.}

\item{custom_sort}{If \code{TRUE}, \code{"Case"} assignment will be in preference to this sort order. Useful in specifying that episode grouping begins at a particular kind of record regardless of chronological order.}

\item{from_last}{If \code{TRUE}, episode grouping will be backwards in time - starting at the most recent record and proceeding to the earliest. If \code{FALSE}, it'll be forward in time - starting at the earliest record and proceeding to the most recent.}

\item{overlap_method}{A set of options by which grouped intervals should overlap. Options are; \code{"none"} (default), \code{"overlap"}, \code{"aligns_start"}, \code{"aligns_end"}, \code{"within"} and \code{"chain"}}

\item{bi_direction}{If \code{FALSE}, \code{"Duplicate"} records are those within the \code{case_length} and \code{recurrence_length} before or after the \code{"Case"} as determined by \code{from_last}. If \code{TRUE}, \code{"Duplicate"} records are those on either side of the \code{"Case"}.}

\item{group_stats}{If \code{TRUE}, output will include additional columns with useful stats for each episode.}

\item{display}{If \code{TRUE}, status messages are not printed on screen.}
}
\value{
Dataframe

\itemize{
\item \code{sn} - the unique record identifier provided
\item \code{epid} - unique episode indentifier
\item \code{case_nm} - record type in regards to case assignment
\item \code{epid_dataset} - datasets contained in each episode
\item \code{epid_interval} - lubridate \code{interval} object. Episode start and end dates
\item \code{epid_length} - \code{difftime} object. Difference between episode start and end dates. Unit for will match that supplied as \code{episode_unit}
\item \code{epid_total} - number of records in each record group
}
}
\description{
This function assigns records into unique chronological episodes
}
\details{
Episode grouping begins at a reference record (\code{"Case"}) and proceeds forward or backward in time depending on \code{from_last}.
If \code{custom_sort} is used, episode grouping can be forced to begin at certain record before proceeding forward or backwards in time.
The maximun duration of a \code{"fixed"} episode is the \code{case_length} while, the maximum duration of a \code{"rolling"} episode is the
\code{case_length} in addition to all recurrence periods. A recurrence period is the \code{recurrence_length} from the last record in an episode
}
\examples{

library(lubridate)
library(dplyr)

data <- data.frame(date = seq.Date(dmy("01/04/2018"), dmy("31/05/2018"), by="6 days"))
data$epi_len <- 15
data <- mutate(data, rd_id = row_number())

# Begin episode grouping at the earliest record thereby making it the "Case"
cbind(data,
      episode_group(data, sn=rd_id, date = date, case_length = epi_len)
      )

# Begin episode grouping at the most recent record thereby making it the "Case"
cbind(data,
      episode_group(data, rd_id, date=date, case_length = epi_len, from_last = TRUE, display = FALSE)
      )

# Rolling episodes
data$recur <- 30
cbind(data,
      episode_group(data, rd_id, date=date, case_length = epi_len, episode_type = "rolling",
                    recurrence_length = recur, display = FALSE)
      )

# Limit the number of recurrence periods
cbind(data,
      episode_group(data, rd_id, date=date, case_length = epi_len, episode_type = "rolling",
                    recurrence_length = recur, rolls_max = 1, display = FALSE)
      )

# Limit the number times episode grouping occurs
cbind(data,
      episode_group(data, rd_id, date=date, case_length = epi_len, episode_type = "fixed",
                    recurrence_length = recur, episodes_max = 1, from_last = FALSE, display = FALSE)
      )

# User defined case assignment
data$infection <- c("BSI", rep("UTI",2), "UTI", "BSI",  "UTI", rep("BSI",2), "RTI","RTI","BSI")

  # preference for case assignment - UTI > BSI > RTI
data$infection <- factor(data$infection, levels = c("UTI","BSI","RTI"))

  # Different case and recurrence lengths for different records
data <- mutate(data,
               epi_len = case_when(
                 infection == "BSI" ~ 14,
                 infection == "UTI" ~ 30,
                 infection == "RTI" ~ 60
                 )
               )

cbind(data,
      episode_group(data, rd_id, date=date, case_length = epi_len,
                    recurrence_length = recur, custom_sort = infection, from_last = FALSE, display = FALSE)
      )

  # Can make it such that only combination with BSI records will have a specified preference for case assignment
  # When it's a combination without a "BSI" record, preference for case assignment reverts back to the earliest or most recent record depending on from_last
data$infection_ord <- ifelse(data$infection =="BTI",0,1)

cbind(data,
      episode_group(data, rd_id, date=date, case_length = epi_len,
                    custom_sort = infection_ord, group_stats = TRUE, from_last = FALSE, bi_direction = TRUE, display = FALSE)
)

  # Can make it such that duplicates on either side of the case are grouped into the same episode
data$infection_ord <- ifelse(data$infection =="RTI",0,1)

cbind(data,
      episode_group(data, rd_id, date=date, case_length = epi_len,
                   custom_sort = infection_ord, group_stats = TRUE, from_last = FALSE, bi_direction = TRUE, display = FALSE)
      )

# Stratified episode grouping
data$patient_id <- c(rep("PID 1",8), rep("PID 2",3))
cbind(data,
      episode_group(data, rd_id, date=date, strata = patient_id, case_length = epi_len,
                    recurrence_length = recur, episodes_max = 1, from_last = FALSE, display = FALSE)
      )

cbind(data,
      episode_group(data, rd_id, date=date, strata = c(patient_id, infection), case_length = epi_len,
                    recurrence_length = recur, episodes_max = 1, from_last = FALSE, display = FALSE)
      )

# data_source is useful when grouping episodes across multiple datasets or as diagnostic option
cbind(data,
      episode_group(data, rd_id, date=date, case_length = epi_len, episode_type = "fixed",
                    recurrence_length = recur, episodes_max = 1, data_source = c(patient_id, infection), display = FALSE)
)

hopital_record <- data.frame(
  rd_id = 1:8,
  admin_dt = c(dmy("01/01/2010"), dmy("01/01/2010"), dmy("05/01/2010"), dmy("05/01/2010"), dmy("07/01/2010"), dmy("04/01/2010"), dmy("20/01/2010"), dmy("26/01/2010")),
  discharge_dt = c(dmy("01/01/2010"), dmy("10/01/2010"), dmy("06/01/2010"), dmy("15/01/2010"), dmy("15/01/2010"), dmy("13/01/2010"), dmy("30/01/2010"), dmy("31/01/2010"))
)

hopital_record$epi_len <- 0
hopital_record$admin_period <- interval(hopital_record$admin_dt, hopital_record$discharge_dt)

# time point, fixed episode grouping
cbind(
  hopital_record,
  episode_group(hopital_record, date=admin_dt, sn=rd_id, case_length = epi_len, group_stats = TRUE)
  ) \%>\% select(-admin_period)

# time interval, fixed episode grouping
cbind(
  hopital_record,
  episode_group(hopital_record, date=admin_period, sn=rd_id, case_length = epi_len)
  ) \%>\% select(-c(admin_dt, discharge_dt))

#time interval, rolling episode.
cbind(hopital_record,
      episode_group(hopital_record, date=admin_period, sn=rd_id, case_length = epi_len, episode_type = "rolling")
      ) \%>\% select(-c(admin_dt, discharge_dt))

#Episodes of overlapping intervals
cbind(
  hopital_record,
  episode_group(hopital_record, date=admin_period, sn=rd_id, case_length = epi_len, overlap_method = "overlap")
  ) \%>\% select(-c(admin_dt, discharge_dt))

#Episodes of intervals within other intervals
cbind(
  hopital_record,
  episode_group(hopital_record, date=admin_period, sn=rd_id, case_length = epi_len, overlap_method = "within")
  ) \%>\% select(-c(admin_dt, discharge_dt))

#Episodes of chained intervals episodes, and those with aligned end periods
cbind(
  hopital_record,
  episode_group(hopital_record, date=admin_period, sn=rd_id, case_length = epi_len, overlap_method = c("chain","aligns_end"))
  ) \%>\% select(-c(admin_dt, discharge_dt))
}
\seealso{
\code{\link{record_group}}
}
