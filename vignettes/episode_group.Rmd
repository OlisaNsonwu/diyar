---
title: "Implementing case definitions for epidemiological analysis in R"
date: "`r format(Sys.Date(), '%d %B %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Implementing case definitions for epidemiological analysis in R}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

#Introduction
Deduplicating events is a major part of establishing a case definition in epidemiological analyses. In such analyses, you select a reference event (`"Case (C)"`) which is taken as the start of an episode. Subsequent events within a specified period after the reference event are then considered duplicates `"(D)"`.

`fixed_episodes()`, `rolling_episodes()` and `episode_group()` aims to provide a simple but flexible way of grouping records from multiple data sources into episodes. This then allows for the deduplication of the dataset, or a sub-analysis within each episode.

#Uses
The flexible application of [`record_group`](record_group.html) and, `fixed_episodes()`, `rolling_episodes()` or `episode_group()` can allow you apply a different case definitions to a dataset. Some examples below;

1. Create episodes of events that occur at a point in time e.g. diagnosis. See [episode grouping](#episode_grouping) and [Useful ways of using episode_group](#tips)
2. Create episodes of overlapping periods of events e.g. hospital stay. See [interval grouping](#interval_grouping)
3. Create episodes that reoccur within a defined period (`recurrence_length`) from the last event
3. Specify which event (or period of event) is considered the `"Case (C)"`. See [case assignment](#case_assignment)
4. Create episodes with a different `case_length` and/or `recurrence_length` for different subsets of a dataset. See [stratified grouping](#stratified_grouping)

#Implementation 

<a id= "episode_grouping"></a>

## Overview
An episode as produced by `fixed_episdoes()`, `rolling_episodes()` or `episode_group()` is a set of events (or periods of events) within a specific period of time. Each begins with a reference event - the `"Case (C)"`, and may contain a `"Recurrent (R)"` event. The remaining events are considered duplicates `"(D)"`.

Two type of episodes can be produced;

- `"fixed"` episodes - `"Duplicate (D)"` events (or periods of events) are those within a specified period (`case_length`) after/before the `"Case (C)"`. Any event after this `case_length` is considered a different episode.

- `"rolling"` episodes - `"Duplicate (D)"` events (or periods of events) are those within the `case_length` and those within periods of recurrence. See [episodes windows and recurrence periods](#recurrence).

`"fixed"` and `"rolling"` episodes are created with `fixed_episdoes()` and `rolling_episodes()` respectively, while `episode_group` can create both.

<a id ="recurrence" ><a/> 

##Episode windows and recurrence periods
An episode window (`epid_interval`) is the period between the `"Case"` and the episode's last event (or the end point of the last period). For a `"fixed"` episode, its length is never longer than the `"case_length"`.

A recurrence period is a specified period (`recurrence_length`) after the last record in an epsiode. The first new record within this `recurrence_length` is taken as a `"Recurrent (R)"` record. Others within that period are taken as a `"Duplicate (D)"` of that `"Recurrent (R)"` record. This means that a rolling episode will continue to expand as far as there's a record within the recurrence period of the last record in the episode (`"Case (C)"`, `"Duplicate (C)"` or `"Recurrent (R)"`). As a result, the episode window (`epid_interval`) of a rolling episode is not fixed and depends on the data.

The examples below demonstrates this difference;

```{r message=FALSE, warning=FALSE}
library(dplyr)
library(lubridate)
library(diyar)

data("infections_2")
dates <- infections_2$date

# Fixed episodes
f <- fixed_episodes(date = dates, case_length=14, group_stats = TRUE, to_s4 =TRUE)

# Rolling episodes
r <- rolling_episodes(date = dates, case_length=14, group_stats = TRUE, display = FALSE, to_s4 =TRUE)

dates # dates

f # fixed episode identifiers

r # rolling episode identifiers
```

In the `"fixed"` episodes example, Records 1 to 3 are assigned a unique episode ID (`"E-1"`). In this instance, record 1 is the `"Case (C)"` and records 2 and 3 its duplicates `"(D)"`. This is because records 2 and 3 are dated within 15 days of record 1 (difference of 14 days). Record 4 occured after this 15-day period and so begins a new `"Case (C)"` which is assigned a new episode ID (`"E-4"`). Record 5 is within 15 days of record 4, so is considered a `"Duplicate (D)"` of record 4 and assigned the same episode ID as record 4 (`"E-4"`). This process continues chronologically until all records have been assigned an episode ID.

In the `"rolling"` episode example, records 1 to 3 are also grouped together as episode `"E-1"` however, unlike the `"fixed"` episode example, record 4 is not considered a new `"Case (C)"`. Instead its assigned to episode `"E-1"` as a `"Recurrent (R)"` record. This occured because it was within 8 days of the last `"Duplicate (D)"` (record 3). Record 5 is also assigned to episode `"E-1"` because it's within 8 days of record 4. Record 6 is not within 15 days of the initial `"Case (C)"` (record 1) and not within 8 days of the last record at this stage (record 5), so it's now considered a new `"Case (C)"` and assigned a new episode ID (`"E-6"`).

\newline

**Figure 1: `"Fixed"` and `"rolling"` episodes with their respective `case_lenth` and `recurrence_length`**

```{r echo=FALSE, fig.height=4, fig.width=7, message=FALSE, warning=FALSE}
library(tidyr)
library(ggplot2)
r_epids <- f_epids <- infections_2[c("rid","pid","date")]

f_epids$epids <- f
r_epids$epids <- r

r_epids$dt_a <- start_point(r_epids$epids@epid_interval)
r_epids$dt_z <- end_point(r_epids$epids@epid_interval)
r_epids$case_nm <- r_epids$epids@case_nm
r_epids$epid <- r_epids$epids@.Data

f_epids$dt_a <- start_point(f_epids$epids@epid_interval)
f_epids$dt_z <- end_point(f_epids$epids@epid_interval)
f_epids$case_nm <- f_epids$epids@case_nm
f_epids$epid <- f_epids$epids@.Data

plot <- bind_rows(
  mutate(r_epids, method="rolling episodes"),
  mutate(f_epids, method="fixed episodes")) %>% 
  mutate(epi=7, recur=14) %>% 
  select(method, rid, epid, date, dt_a, dt_z, epi, recur, case_nm) %>% 
  mutate(epid = paste("EP",epid,sep="")) %>% 
  mutate_at(vars(dt_a, dt_z), funs(dmy(format(.,"%d/%m/%Y")))) 

plot <- plot %>% 
  group_by(method, epid) %>% 
  arrange(date) %>% 
  mutate(
    last_record = ifelse(row_number()==n(),1,0),
    recur_dup = ifelse(case_nm=="Duplicate" & !is.na(case_nm[row_number()+1]) & case_nm[row_number()+1] == "Recurrent", 1,0)
    ) %>% 
  ungroup() %>% 
  mutate(
    dash_range = case_when(
      case_nm=="Case" ~ epi, 
      (case_nm =="Recurrent" & last_record !=1) | (recur_dup ==1) ~ recur,
      TRUE ~ 0
    ), 
    dash_num = ifelse(dash_range==0,"",as.character(dash_range)),
    dash_range = date + duration(dash_range,"days")
  )

g_area <- unique(select(plot, method, epid, date=dt_a, dt_z)) 
g_area$rid <- max(plot$rid)

ggplot(plot, aes(x=date, y=rid, group=rid, colour=epid)) +
  geom_point() +
  geom_segment(aes(x=date,xend=dash_range,y=rid,yend=rid), linetype=2) +
  geom_text(aes(hjust="right", label=case_nm), nudge_x = -2, nudge_y = .05, show.legend = FALSE) +
  geom_text(aes(hjust="left", label=dash_num), nudge_x = 2, nudge_y = .18, show.legend = FALSE, size =2.5) +
  scale_y_continuous("Record ID", breaks = 1:6) +
  scale_x_date("Specimen date", limits = c(dmy("15/03/2019"), dmy("01/07/2019") ), date_breaks = "25 days", date_labels = "%d %b") +
  facet_wrap(~method, scales = "free_y") +
  guides(col = guide_legend(nrow = 1)) +
  theme(
    strip.background = element_rect(fill="transparent"),
    axis.line = element_line(colour = "black"),
    panel.grid = element_blank(),
    legend.position = "bottom",
    legend.title = element_blank()
  )
```

***If your case definition does not explicitly require a rolling episode, use `fixed_episode()`. It takes less time to complete.***

<a id="case_assignment"></a> 

## Case assignment
This section covers the different functionalities of these functions that determine which record is taken as the `"Case (C)"`.

### Number of recurrence periods and episodes
You can choose to have a certain number of episodes per `strata` by using `episode_max`. When `episode_max` is reached, any record not yet grouped is assigned a unique episode ID, making it a unique `"Case (C)"`.

```{r warning=FALSE, message=FALSE}
data("infections_3");
dbs <- infections_3[c("pid","date")]; dbs

# Maximum of one episode with one recurrence period
dbs$eps_1 <- rolling_episodes(strata = dbs$pid, date =dbs$date, case_length = 1,display = FALSE, rolls_max = 1, episodes_max = 1, to_s4 = TRUE)

# Maximum of two episodes with one recurrence period
dbs$eps_2 <- rolling_episodes(strata = dbs$pid, date =dbs$date, case_length = 1,display = FALSE, rolls_max = 1, episodes_max = 2, to_s4 = TRUE)

dbs

```

By default, `rolling_episodes()` will continue checking for `"Recurrent" (R)` records indefinitely, but you can limit the number of recurrence periods an episode can have by using `rolls_max`.

```{r warning=FALSE, message=FALSE}
# Infinite recurrence periods per episode (Default)
dbs$eps_3 <- rolling_episodes(strata = dbs$pid, date =dbs$date, case_length = 2,display = FALSE, to_s4 = TRUE)

# Maximum of one recurrence period per episode
dbs$eps_4 <- rolling_episodes(strata = dbs$pid, date =dbs$date, case_length = 2,display = FALSE, rolls_max = 1, to_s4 = TRUE)

# Maximum of two recurrence periods per episode
dbs$eps_5 <- rolling_episodes(strata = dbs$pid, date =dbs$date, case_length = 2,display = FALSE, rolls_max = 2, to_s4 = TRUE)

dbs
```


### Chronological order of events
By default, episode grouping begins at the earliest event (or period of event) and proceeds to the most recent one, making the earliest event the `"Case (C)"`. The opposite of this is to have the most recent record as the `"Case (C)"`. To do this, change `from_last` to `TRUE`. Doing this will start episode grouping at the most recent event and proceed backwards in time to the earliest one.

```{r message=FALSE, warning=FALSE}
dbs <- infections_2[c("date")]; dbs

# Episode grouping in chronological order
dbs$forward <- fixed_episodes(date=dbs$date, case_length= 14,
                              group_stats = TRUE, display = FALSE, to_s4=TRUE)

# Episode grouping in reverse chronological order
dbs$backward <- fixed_episodes(date=dbs$date, case_length= 14, group_stats = TRUE, display = FALSE, from_last=TRUE, to_s4=TRUE)

dbs[c("forward","backward")]
```

<a id ="custom_sort"></a>

### User defined case assignment
You can specify a different preference for case assignment from what's been described above. This is done using `custom_sort`. In `fixed_episodes()` and `rolling_episodes()` this is a vector whose values when sorted in ascending order specifies the required preference. For example, records with a `custom_sort` value of `1` will be preferentially taken as the start of an episode over one with a value of `2`. This is prioritised over the chronological order records. See the example below.

```{r message=FALSE, warning=FALSE}
dates <- c("01/04/2019", "05/04/2019", "07/04/2019")
dates <- as.Date(dates,"%d/%m/%Y")
user_sort <- c(2,1,2)

# preference determined by from_last 
fixed_episodes(date=dates, case_length=6, to_s4=TRUE, display=FALSE)

# user defined preference via custom sort is prioritised before from_last 
fixed_episodes(date=dates, case_length=6, to_s4=TRUE, custom_sort = user_sort, display=FALSE)

# user defined preference via custom sort is prioritised before from_last. Duplicates flagged from both directions
fixed_episodes(date=dates, case_length=6, to_s4=TRUE, custom_sort = user_sort, display=FALSE, bi_direction = TRUE)

```

In the second example above, even though the second record occured after the first, episode grouping begins at the second record and then continues chronologically in the direction specified by `from_last`. 

A consequence of using `custom_sort` was that record 1 was not grouped together with record 2 even though its within the `case_length` of record 2. This is because duplicates are tracked in one direction, and determined by `from_last`. To track dupliciates from both directions use `bi_direction` as shown in the third example.   

Note that example 1 and 3 now have the same number of duplicates (and episodes) but different cases - records 1 and 2 respectively.

***`custom_sort` can be `"character"`, `"numeric"` or `"factor"` data types. However, each would follow `R` standard sort behaviour. For example, a `factor` will sort on its levels not the descriptive label.***

For a practical example, we'll use this feature for a case definition where *E. coli* urinary tract infections (UTI) are considered precursors to *E. coli* bloodstream infections (BSI). This means that episodes need to be created in such a way that; if there are UTI and BSI records within the same `case_length`, the UTI record will be taken as the `"Case (C)"`. 

```{r message=FALSE, warning=FALSE}
dbs <- infections_2[c("date","infx")]; dbs
dbs$infx <- gsub("E. coli ","",dbs$infx)
dbs$infx[c(2,5)] <- "UTI"

dbs$epids_1 <- fixed_episodes(date=dbs$date, case_length=14, 
                custom_sort = dbs$infx, display = FALSE, to_s4 = TRUE)

dbs$infx_f <- factor(dbs$infx, levels = c("UTI","BSI"))

dbs$epids_2 <- fixed_episodes(date=dbs$date, case_length=14, 
                custom_sort = dbs$infx_f, display = FALSE, to_s4 = TRUE)

dbs$epids_3 <- fixed_episodes(date=dbs$date, case_length=14, 
                custom_sort = dbs$infx_f, display = FALSE, to_s4 = TRUE, bi_direction = TRUE)

dbs
```

In `epids_2`, after changing the sort preference using factor levels, record 1 (*E. coli* BSI)  and record 2 (*E. coli* UTI) are no longer part of the same episode. This is because record 2, is now the reference record where episode grouping began, and since record 1 occurred before record 2, they are not grouped together. `epids_3` is episode grouping when `bi_direction` is used.

***In `episode_group()`, you can implement `custom_sort` in levels. You do this by creating a colum for each level. The column names, listed in the prefered order (level) is then supplied to `custom_sort`.***

<a id="interval_grouping"></a>

## Interval grouping
In this section we discuss the process of grouping periods of events into episodes. Each period or interval is essentially a record with a start and end point in time. For the purpose of episode grouping, these intervals are created as `number_line` objects and supplied to the `date` argument.

The simple example below demonstrates the difference between grouping events and periods of events.

```{r message=FALSE, warning=FALSE}
dbs <- tibble(date=c("01/04/2019", "05/04/2019"))

dbs$date <- as.Date(dbs$date, "%d/%M/%Y")
dbs$period <- number_line(dbs$date, dbs$date + 10)

dbs

fixed_episodes(date=dbs$date, case_length=30, to_s4=TRUE, display=FALSE, group_stat=TRUE)

fixed_episodes(date=dbs$period, case_length=30, to_s4=TRUE, display=FALSE, group_stat=TRUE)
```

In the example below, we group periods of hospital stay into episodes. This is different from grouping the admission or discharge events themselves.

```{r message=FALSE, warning=FALSE}
data("hospital_admissions"); hospital_admissions

hospital_admissions$admin_period <- number_line(hospital_admissions$admin_dt, hospital_admissions$discharge_dt)

# Grouping the actual admissions into episodes
fixed_episodes(date=hospital_admissions$admin_dt, sn=hospital_admissions$rd_id, case_length = 0, 
                display = FALSE, to_s4 = TRUE, group_stats = TRUE)

# Grouping the periods of stay (admission -> discharge)
fixed_episodes(date=hospital_admissions$admin_period, sn=hospital_admissions$rd_id, case_length = 0, 
                display = FALSE, to_s4 = TRUE, group_stats = TRUE)

```

Intervals are grouped into the same episode when they overlap. Since this can happen in different ways, each function allows you to choose how this happens by using `overlap_method`. The options available are; `"across"`, `"inbetween"`, `"chain"`, `"aligns_start"` and `"aligns_end"`. The default option is to use all methods. The examples and figure below demonstrates each method.

```{r warning=FALSE}
# Overlapping intervals
across <- fixed_episodes(date=hospital_admissions$admin_period, sn=hospital_admissions$rd_id, case_length = 0, 
               overlap_method = "across", display = FALSE, to_s4 = TRUE, group_stats = TRUE)

across

# Chained intervals
chain <- fixed_episodes(date=hospital_admissions$admin_period, sn=hospital_admissions$rd_id, case_length = 0, 
               overlap_method = "chain", display = FALSE, to_s4 = TRUE, group_stats = TRUE)

chain

# Intervals with aligned end points
aligns_end <- fixed_episodes(date=hospital_admissions$admin_period, sn=hospital_admissions$rd_id, case_length = 0, 
               overlap_method = "aligns_end", display = FALSE, to_s4 = TRUE, group_stats = TRUE)

aligns_end

# Intervals with aligned start points
aligns_start <- fixed_episodes(date=hospital_admissions$admin_period, sn=hospital_admissions$rd_id, case_length = 0, 
               overlap_method = "aligns_start", display = FALSE, to_s4 = TRUE, group_stats = TRUE)

aligns_start

# Intervals occurring completely within others
inbetween <- fixed_episodes(date=hospital_admissions$admin_period, sn=hospital_admissions$rd_id, case_length = 0, 
               overlap_method = "inbetween", display = FALSE, to_s4 = TRUE, group_stats = TRUE)

inbetween

# Chained intervals and those occurring completely within others
chain_inbetween <- fixed_episodes(date=hospital_admissions$admin_period, sn=hospital_admissions$rd_id, case_length = 0, 
               overlap_method = c("chain","inbetween"), display = FALSE, to_s4 = TRUE, group_stats = TRUE)

chain_inbetween

```

**Figure 2: Different options for `overlap_method` using a case_length of `"0"` days.**
```{r echo=FALSE, fig.height=5, fig.width=8, message=FALSE, warning=FALSE}
across <- cbind(hospital_admissions, to_df(across))
chain <- cbind(hospital_admissions, to_df(chain))
aligns_start <- cbind(hospital_admissions, to_df(aligns_start))
chain_inbetween <- cbind(hospital_admissions, to_df(chain_inbetween))
inbetween <- cbind(hospital_admissions, to_df(inbetween))
aligns_end <- cbind(hospital_admissions, to_df(aligns_end))

plot <- rbind(
  mutate(across, method="across"),
  mutate(chain, method="chain"),
  mutate(aligns_start, method="aligns_start"),
  mutate(aligns_end, method="aligns_end"),
  mutate(inbetween, method="inbetween"), 
  mutate(chain_inbetween, method="chain and inbetween")
  )

plot <- mutate(plot,
  mrk=paste(epid, method,sep="_"),
  admin_dt = dmy(format(left_point(admin_period), "%d/%m/%Y")),
  discharge_dt = dmy(format(right_point(admin_period), "%d/%m/%Y"))
  ) %>% select(-admin_period)

plot <- dplyr::arrange(plot, .data$mrk)
plot$N <- rep(rle(plot$mrk)$lengths, rle(plot$mrk)$lengths)

plot <- plot %>%
  mutate(epid_2 = paste(method, ": epid ",epid, sep="" )) %>% 
  select(rd_id, epid, epid_2, admin_dt, discharge_dt, method, N, epid, case_nm) %>%
  filter(N>1) %>%
  select(rd_id, admin_dt, discharge_dt, method, epid, epid_2, case_nm) %>%
  gather(var, val, -c(rd_id, method, epid, epid_2, case_nm)) %>%
  mutate(
    rd_id = as.character(rd_id), 
    lab =ifelse(case_nm=="Case" & var=="admin_dt", case_nm, ""), 
    method = factor(method, levels = c("across","aligns_start","aligns_end","chain", "inbetween", "chain and inbetween"))
    )

ggplot(plot, aes(x=val, y=rd_id, group=rd_id, label=lab, colour=epid_2)) +
  geom_line(aes(colour=epid_2)) +
  geom_point() +
  geom_text(aes(hjust="right"), nudge_x = -2, nudge_y = .05, show.legend = FALSE) +
  scale_y_discrete("Record ID") +
  scale_x_date("Admitted period", limits = c(dmy("15/12/2018"), dmy("10/02/2019")), date_breaks = "20 days", date_labels = "%d %b") +
  guides(col = guide_legend(nrow = 2)) +
  facet_wrap(~method, scales = "free_y") +
  theme(
    strip.background = element_rect(fill="transparent"),
    axis.line = element_line(colour = "black"),
    panel.grid = element_blank(),
    legend.position = "bottom",
    legend.title = element_blank()
  )

```

```{r warning=FALSE, include=FALSE}

# Overlapping intervals
ha2 <- hospital_admissions
ha2$epi_len <- 30
ha2$shift <- ifelse(ha2$rd_id %in% c(2,8,5,7), 0, 30)
ha2$admin_period <- shift_number_line(ha2$admin_period, duration(ha2$shift, "days"))

# Overlapping intervals
across <- fixed_episodes(date=ha2$admin_period, sn=ha2$rd_id, case_length = 30, 
               overlap_method = "across", display = FALSE, to_s4 = TRUE, group_stats = TRUE)

# Chained intervals
chain <- fixed_episodes(date=ha2$admin_period, sn=ha2$rd_id, case_length = 30, 
               overlap_method = "chain", display = FALSE, to_s4 = TRUE, group_stats = TRUE)

# Intervals with aligned end points
aligns_end <- fixed_episodes(date=ha2$admin_period, sn=ha2$rd_id, case_length = 30, 
               overlap_method = "aligns_end", display = FALSE, to_s4 = TRUE, group_stats = TRUE)

# Intervals with aligned start points
aligns_start <- fixed_episodes(date=ha2$admin_period, sn=ha2$rd_id, case_length = 30, 
               overlap_method = "aligns_start", display = FALSE, to_s4 = TRUE, group_stats = TRUE)

# Intervals occurring completely within others
inbetween <- fixed_episodes(date=ha2$admin_period, sn=ha2$rd_id, case_length = 30, 
               overlap_method = "inbetween", display = FALSE, to_s4 = TRUE, group_stats = TRUE)

# Chained intervals and those occurring completely within others
chain_inbetween <- fixed_episodes(date=ha2$admin_period, sn=ha2$rd_id, case_length = 30, 
               overlap_method = c("chain","inbetween"), display = FALSE, to_s4 = TRUE, group_stats = TRUE)

# Chained intervals and those with aligned end points
chain_aligns_end <- fixed_episodes(date=ha2$admin_period, sn=ha2$rd_id, case_length = 30, 
               overlap_method = c("chain","aligns_end"), display = FALSE, to_s4 = TRUE, group_stats = TRUE)

```

**Figure 3: Different options for `overlap_method` using a case_length of `"30"` days**
```{r echo=FALSE, fig.height=5.5, fig.width=8, message=FALSE, warning=FALSE}
across <- cbind(ha2, to_df(across))
chain <- cbind(ha2, to_df(chain))
aligns_start <- cbind(ha2, to_df(aligns_start))
chain_inbetween <- cbind(ha2, to_df(chain_inbetween))
chain_aligns_end <- cbind(ha2, to_df(chain_aligns_end))
inbetween <- cbind(ha2, to_df(inbetween))
aligns_end <- cbind(ha2, to_df(aligns_end))

plot <- rbind(
  mutate(across, method="across"),
  mutate(chain, method="chain"),
  mutate(aligns_start, method="aligns_start"),
  mutate(aligns_end, method="aligns_end"),
  mutate(inbetween, method="inbetween"), 
  mutate(chain_inbetween, method="chain and inbetween"), 
  mutate(chain_aligns_end, method="chain and aligns_end")
  )

plot <- mutate(plot,
  mrk=paste(epid, method,sep="_"),
  admin_dt = dmy(format(left_point(admin_period), "%d/%m/%Y")),
  discharge_dt = dmy(format(right_point(admin_period), "%d/%m/%Y"))
  ) %>% select(-admin_period)

plot <- dplyr::arrange(plot, .data$mrk)
plot$N <- rep(rle(plot$mrk)$lengths, rle(plot$mrk)$lengths)

plot <- plot %>%
  mutate(epid_2 = paste(method, ": epid ",epid, sep="" )) %>% 
  select(rd_id, epid, epid_2, admin_dt, discharge_dt, method, N, epid, case_nm, epi_len) %>%
  filter(N>1) %>%
  select(rd_id, admin_dt, discharge_dt, method, epid, epid_2, case_nm, epi_len) %>%
  gather(var, val, -c(rd_id, method, epid, epid_2, case_nm, epi_len)) %>%
  mutate(
    rd_id = as.character(rd_id), 
    lab =ifelse(case_nm=="Case" & var=="admin_dt", case_nm, ""), 
    method = factor(method, levels = c("across","aligns_start","aligns_end","chain", "inbetween",
                                       "chain and inbetween", "chain and aligns_end","aligns_start and aligns_end"))
    )

ep_plot <- filter(plot, var=="discharge_dt" & case_nm == "Case") %>% 
  mutate(var="start")

#ep_plot$k <- ifelse(ep_plot$case_nm=="Case", ep_plot$epi_len, ep_plot$recur_len)

ep_plot <- mutate(ep_plot, val= val + duration(epi_len,"days"), var="end") %>% 
  bind_rows(ep_plot)

ggplot(plot, aes(x=val, y=rd_id, group=rd_id, label=lab, colour=epid_2)) +
  geom_line() +
  geom_point() +
  geom_text(aes(hjust="right"), nudge_x = -2, nudge_y = .05, show.legend = FALSE) +
  geom_line(data=ep_plot, aes(x=val, y=rd_id, group=rd_id, colour=epid_2), linetype=2) +
  scale_y_discrete("Record ID") +
  scale_x_date("Admitted period", limits = c(dmy("15/12/2018"), dmy("01/04/2019")), date_breaks = "35 days", date_labels = "%d %b") +
  guides(col = guide_legend(nrow = 4)) +
  facet_wrap(~method, scales = "free_y") +
  theme(
    strip.background = element_rect(fill="transparent"),
    axis.line = element_line(colour = "black"),
    panel.grid = element_blank(),
    legend.position = "bottom",
    legend.title = element_blank()
  )

```


<a id="stratified_grouping"></a>

## Stratified episode grouping
Episode grouping can be done separately for different subsets (`strata`) of the dataset. Examples of a `strata` could be patient IDs, type of pathogen, source of infection or a combination of these parameters. Episodes will be limited to each `strata` however, episodes from different `strata` but can have different `case_length` and `recurrence_length`.

`record_group()` is useful for creating a group identifiers which can used as a `strata`. See [record group](record_group.html) for further details.

As an example, using the `infections` dataset, a case definition may specify the following;

- UTI and BSI records are considered different episodes regardless of when they occur
- UTI has a `case_length` of 7 days and recurrence period of 30 days
- BSI has a `case_length` of 14 days and no recurrence period

In the example below, adding `infection` to the `strata` argument means that `"UTI"` and `"BSI"` records will not be in the same episode. Furthermore, the `case_length` and `recurrence_length` for each will be different as specified in the `epi` and `recur` columns respectively 
```{r warning=FALSE}
data(infections)
dbs <- infections[c("date","infection")]
dbs$epi <- ifelse(dbs$infection=="UTI", 7, 14)
dbs$recur <- ifelse(dbs$infection=="UTI", 30, 0)

dbs$epids <- rolling_episodes(date=dbs$date, case_length =dbs$epi, to_s4 =TRUE,
                            recurrence_length = dbs$recur, display = FALSE, group_stats = TRUE)

dbs
```

<a id="sub_strata"></a>

### Sub-strata
A sub-strata is created when records within a `strata` have a different `case_length` or `recurrence_length`. The case definition below demonstrates how this can be used.

- UTI and BSI records are different episodes regardless of when they occur. 
- UTI have a `case_length` of 7 days and recurrence period of 30 days
- BSI have a `case_length` of 14 days if not treated, **OR** `case_length` of 4 days if treated, and no recurrence period in both situations
- Respiratory tract infections (RTI) have a `case_length` of 28 days and recurrence period of 5 days

In this example, whether or not the infection is treated should be taken as the sub-strata, and the source of infection taken as the `strata`.

```{r warning=FALSE}
data("infections_4"); 
dbs <- infections_4

dbs$epids <- episode_group(infections_4, sn=rid, strata=c(pid, organism, source), date=date, 
                case_length =epi, episode_type = "rolling", recurrence_length = recur,
                display = FALSE, to_s4 = TRUE)

dbs
```

There are a few things to note with stratified grouping;

- Unless required, `case_length` and `recurrence_length` should be consistent across each `strata` otherwise, you'll inadvertently create a sub-strata
- Episode grouping with and without a sub-strata is different and could lead to different results
- Using sub-strata is not the same as adding that sub-strata to the `strata` argument. In the example above, adding `treated` to `strata` will group treated infections separately from untreated infections. While this could be the desired outcome depending on your case definition, the case definition above did not required treated and untreated infections to be grouped separately, only that the treated infections last longer. The example below demonstrates this difference;

Stratified grouping is the same as a separate analysis for each subset (`strata`) of the dataset.

<a id="tips"></a>

## Useful ways of using episode_group 
### Episode grouping across other units of time
In the examples above, episode grouping was done by the days (`episode_unit`). However, it can be done in other units of time e.g. hours, days or weeks. Acceptable options are those supported by `lubridate's duration()` function. Below is an example of episode grouping by the hour.

```{r warning=FALSE, message=FALSE}
data("hourly_data"); hourly_data

cbind(
  select(hourly_data, datetime),
  episode_group(hourly_data, rid, category, datetime, epi, episode_type = "rolling", episode_unit = "hours", recurrence_length = recur, group_stats = TRUE)
  )
```

### Limit episode grouping to a subset of the dataframe
To exclude a subset of the data from episode grouping, you can separate the `data.frame` and use `episode_group()` on only the desired subset, before joining it back to the original dataset. `episode_group()` has a convenience feature to achieve the same thing. To use this, assign `NA` to the `strata` to be excluded. These records will be excluded from episode grouping and assigned a unique episode ID.

For example, with the `hourly_data`, you can decide to exclude `"GP1"` and `"GP2"` records from episode grouping as shown below. 

```{r warning=FALSE, message=FALSE}
head(hourly_data, 10) %>% 
  mutate(subset = ifelse(category!="GP3", NA, "group")) %>% 
  cbind(.,episode_group(., rid, subset, datetime, epi, episode_type = "rolling", episode_unit = "hours", 
                        recurrence_length = recur, display = TRUE, group_stats = TRUE))
```

### fixed_episodes and rolling_episodes functions
`fixed_episodes()` and `rolling_episodes()` are convenient implementation of `episode_group()`. They return `number_line` objects (`epid_interval`) with the record identifier supplied (`id` slot) and episode identifiers created (`gid` slot).

***Both functions are less efficient in dealing with large datasets and lack the following features; "custom_sort", "rolls_max", "episodes_max", "data_source", "episode_unit", "bi_direction" and "group_stats"***

```{r warning=FALSE, message=FALSE}
data(infections); infections
db_a <- infections

# Fixed episodes
f_epi <- fixed_episodes(x = db_a$date, case_length = db_a$epi_len, display = FALSE, group_stats = TRUE)$epid_interval
f_epi; str(f_epi)

# Rolling episodes
r_epi <- rolling_episodes(x = db_a$date, case_length = db_a$epi_len, recurrence_length = 40, display = FALSE, group_stats = TRUE)$epid_interval
f_epi; str(f_epi)

# Working with a data.frame
db_b <- mutate(db_a, epid_interval= fixed_episodes(x = date, case_length = epi_len, strata = infection, display = FALSE, group_stats = TRUE)$epid_interval)

# Extract useful episode information from the number_line objects
db_b$epid <- db_b$epid_interval@gid
db_b$epid_length <- number_line_width(db_b$epid_interval)
select(db_b, rd_id, date, epid_interval, epid, epid_length)
```

# Conclusion
There are a variety of ways to use this function. It's worth reviewing your case definition and its implication on the dataset before using this function. In general, the following steps will guide you on how to use this function;

1. Work out which columns should be the `strata`
2. Choose whether you need `"fixed"` or `"rolling"` episodes
3. Choose whether you are grouping individual events or a duration of events by supply a date, datetime or `lubridate interval` object as required. See [interval grouping](#interval_grouping)
4. Create a column for `case_length`, and/or `recurrence_length`. The values should be unique to each `strata` unless you require a [sub-strata](#sub_strata)
5. Change `from_last` to `TRUE` if you want to start episode grouping at the most recent record thereby making it the `"Case"`. Note that this is not the same as starting episode grouping at the earliest record (`from_last` is `FALSE`) and then picking the most recent record in that episode as the `"Case"`. See [case assignment](#case_assignment)
6. If you require the `"Case"` to be the earliest or most recent record of a particular type of record, use `custom_sort` in combination with `from_last`. If not, ignore this argument. See [user defined case assignment](#custom_sort)
7. If you require episodes to include records on either side of the `"Case"` use `bi_direction`. If not, ignore this argument
8. Choose if episodes are occurring by the minute, hour or day etc., and set `episode_unit` accordingly
