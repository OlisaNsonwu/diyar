---
title: "Implementing case definitions for epidemiological analysis in R"
date: "`r format(Sys.Date(), '%d %B %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Implementing case definitions for epidemiological analysis in R}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

#Introduction
Deduplicating events is an important step in establishing a case definition in epidemiological analyses. For the most part, this involves selecting a reference event which represents an episode. Subsequent events within a specified period are then taken as duplicates of this reference event.

`fixed_episodes()`, `rolling_episodes()` and `episode_group()` provide simple but flexible ways of grouping records from multiple datasets into episodes. This then allows for easy deduplication or a sub-analysis within each episode.

#Uses
You can use [`record_group()`](record_group.html) and these episode grouping functions to implement a variety of case definitions. For example, in grouping;

1. Episodes from events that occur at a point in time e.g. medical diagnoses or traffic incidents
2. Episodes from events that occur within a period of time e.g. hospital stay. See [interval grouping](#interval_grouping)
3. Episodes with defined periods of reccurence (`recurrence_length`)
3. Episodes with specific events as their reference event. See ["Making a case definition"](#case_assignment)
4. Episodes with different durations (`case_length`) or recurrence periods (`recurrence_length`) per subset (`strata`) of a dataset. See [stratified grouping](#stratified_grouping)

#Implementation 

<a id= "episode_grouping"></a>

## Overview
An episode as produced by `fixed_episodes()`, `rolling_episodes()` or `episode_group()` is a set of dated records (events or periods of events) within a specific period. Each episode begins with a reference event (case) and may contain recurrent events. Events that occur between cases and recurrent events are considerded duplicates.

There are two main type of episodes - `"fixed"` episodes which do not include periods of recurrence and `"rolling"` episodes which do. They are created by `fixed_episodes()` and `rolling_episodes()` respectively while `episode_group()` can create both.

<a id ="recurrence" ><a/> 

## Episodes, windows, case lengths and recurrence periods
Before we begin, let's go over some terms which will pop up now and again. An `event` is simply a dated record. A `period of event` or `event period` is a record with a start and end points in time. The "lengths" - `case_length` and `recurrence_length` are specific durations starting with an `event`. More specifically, the `case_length` is the duration starting with the `reference event` (first `event` of an `episode`) while `recurrence_length` is the duration starting from any other `event` subsequent to the `referenece event`. 

All `events` within a `case_length` or `recurrence_length` form a `window`. A `window` equates to an `episode`. `events` outside a `window` belong to a different episode and are assigned accordingly. What differetiates `rolling episodes` from `fixed episodes` is that when two or more `windows` overlap, they are `collpased` into one longer `window`. As a result, every `event` that belonged to the overlapping `windows` will now belong to this new and longer `window` (and by definition `episode`). So by definition, a `"fixed episode"` is never longer than its `case_length` where as a `rolling episode` becomes longer than its `case_length` if the first `window` (also refered to `case window`) overlaps with another.

See the illustration below.

**Figure 1a: Illustration of key terms - fixed episodes**
```{r message=FALSE, warning=FALSE}
library(tidyr); library(ggplot2);
library(diyar)

ds <- c("01/04/2019", "03/04/2019", "13/04/2019","16/04/2019")
ds <- data.frame(date= as.Date(ds, "%d/%m/%Y"))
ds$f1 <- fixed_episodes(ds$date, case_length = 5, to_s4 = T)
ds
```

```{r echo=FALSE, fig.height=3, fig.width=7, message=FALSE, warning=FALSE}
df <- ds
df$c <- 5
df <- cbind(df, to_df(df$f1))
df$epid <- as.character(df$epid)

pts <- df[c("date", "epid", "window", "case_nm")]
pts$y <- 1
pts$e_lab <- ifelse(pts$case_nm=="Case", paste0("Episode ", as.numeric(as.factor(pts$epid)), ""),"")
pts$w_lab <- ifelse(pts$case_nm=="Case", paste0("Window ", as.numeric(as.factor(pts$window)), ""),"")
pts$y2 <- 0.9
pts$y3 <- 0.8

cl <- df[df$case_nm=="Case",c("date", "epid", "c")] 
cl$end_dt <- cl$date + 5
cl <- gather(cl, vr, date, -c(epid, c))  
cl$y <- 1.08
cl$lab <- ifelse(cl$vr=="date", paste0("Case length (",cl$c,"-day difference)"), "") 

pts$case_nm <- ifelse(pts$case_nm =="Case", "Case\n(Reference)", paste0(pts$case_nm,"\nEvent"))

ggplot(data= pts) +
  geom_point(aes(x=date, y=y, group=epid, colour =epid)) +
  geom_text(aes(x=date, y=y, group=epid, colour =epid, label=case_nm, hjust="left"), nudge_x = .1, size=3) +
  geom_line(aes(x=date, y=y3, group=epid, colour =epid), arrow = arrow(length=unit(0.1,"cm"), ends="both", type = "closed")) +
  geom_text(aes(x=date, y=y3, group=epid, colour =epid, label=e_lab, hjust="left"), nudge_y = -.03, nudge_x = .1, size=3) +
  geom_line(aes(x=date, y=y2, group=epid, colour =epid), arrow = arrow(length=unit(0.1,"cm"), ends="both", type = "closed")) +
  geom_text(aes(x=date, y=y2, group=epid, colour =epid, label=w_lab, hjust="left"), nudge_y = -.03, nudge_x = .1, size=3) +
  geom_line(data=cl, aes(x=date, y=y, group=epid, colour =epid), arrow = arrow(length=unit(0.2,"cm"), ends="last", type = "closed")) +
  geom_text(data=cl, aes(x=date, y=y, group=epid, colour =epid, label=lab, hjust="left"),  nudge_y = .03, size=3) +
  scale_x_date("", date_breaks = "1 day", date_labels = "%d") +
  lims(y=c(0.6,1.25)) +
  theme(
    axis.ticks.y = element_blank(),
    axis.title.y = element_blank(),
    strip.background = element_rect(fill="transparent"),
    axis.line = element_line(colour = "black"),
    axis.text.y = element_blank(),
    panel.grid = element_blank(),
    legend.position = "none",
    legend.title = element_blank()
  )
```

**Figure 1b: Illustration of key terms - rolling episodes**
```{r message=FALSE, warning=FALSE}
ds$r1 <- rolling_episodes(ds$date, case_length = 5, recurrence_length = 10, to_s4 = T, display = F)
ds
```

```{r echo=FALSE, fig.height=4, fig.width=7, message=FALSE, warning=FALSE}
library(lubridate)
df <- ds
df$r <- 10
df$c <- 5

df <- cbind(df, to_df(df$r1))
df$epid <- as.character(df$epid)
df$window <- paste0("W",as.character(df$window))

pts <- df[c("date", "epid", "window")]
pts$case_nm <- c("Case\n(Reference)", "Duplicate\n(Reference) Event", "Recurrent\nEvent","Duplicate\nEvent")
pts$y <- 1
pts$e_lab <- ifelse(!duplicated(pts$epid, fromLast = T), paste0("Episode ", as.numeric(as.factor(pts$epid)), ""),"")
pts$w_lab <- ifelse(!duplicated(pts$window, fromLast = T), paste0("Window ", as.numeric(as.factor(pts$window)), ""),"")
pts$y2 <- 0.7
pts$y3 <- 0.6

cl <- df[df$case_nm=="Case",c("date", "epid", "c")] 
cl$end_dt <- cl$date + cl$c
cl <- gather(cl, vr, date, -c(epid, c))  
cl$y <- 1.1
cl$lab <- ifelse(cl$vr=="date", paste0("Case length (",cl$c,"-day difference)"), "") 

rl <- df[2:3, c("date", "epid", "r", "window")] 
rl$end_dt <- rl$date + c(10,3)
rl <- gather(rl, vr, date, -c(epid, window, r))  
rl$y <- 0.8
rl$lab <- ifelse(rl$vr=="date", paste0("Recurrence length (",rl$r,"-day difference)"), "") 

ggplot(data= pts) +
  geom_point(aes(x=date, y=y, group=epid, colour =epid)) +
  geom_text(aes(x=date, y=y, group=epid, colour =epid, label=case_nm, hjust="left"), nudge_x = .2, size=3) +
  geom_line(aes(x=date, y=y3, group=epid, colour =epid), arrow = arrow(length=unit(0.1,"cm"), ends="both", type = "closed")) +
  geom_text(aes(x=date, y=y3, group=epid, colour =epid, label=e_lab, hjust="left"), nudge_y = -.03, nudge_x = -5, size=3) +
  geom_line(aes(x=date, y=y2, group=epid, colour =window), arrow = arrow(length=unit(0.1,"cm"), ends="both", type = "closed")) +
  geom_text(aes(x=date, y=y2, group=window, colour =epid, label=w_lab, hjust="left"), nudge_y = -.03, nudge_x = -1.6, size=3) +
  geom_line(data=cl, aes(x=date, y=y, group=epid, colour =epid), arrow = arrow(length=unit(0.2,"cm"), ends="last", type = "closed")) +
  geom_text(data=cl, aes(x=date, y=y, group=epid, colour =epid, label=lab, hjust="left"),  nudge_y = .04, size=3) +
  
  geom_line(data=rl, aes(x=date, y=y, group=window, colour =epid), arrow = arrow(length=unit(0.2,"cm"), ends="last", type = "closed"), linetype=2) +
  geom_text(data=rl, aes(x=date, y=y, group=epid, colour =epid, label=lab, hjust="left"),  nudge_y = .04, size=3) +
  
  scale_x_date("", date_breaks = "1 day", date_labels = "%d", limits = c(dmy("01/04/2019"), dmy("18/04/2019") )) +
  lims(y=c(0.5,1.25)) +
  theme(
    axis.ticks.y = element_blank(),
    axis.title.y = element_blank(),
    strip.background = element_rect(fill="transparent"),
    axis.line = element_line(colour = "black"),
    axis.text.y = element_blank(),
    panel.grid = element_blank(),
    legend.position = "none",
    legend.title = element_blank()
  )
```

### Let's try an example of each
```{r message=FALSE, warning=FALSE}
library(dplyr); library(lubridate); library(diyar)

data("infections_2")
dates <- infections_2$date

# Fixed episodes
f <- fixed_episodes(date = dates, case_length=14, group_stats = T, to_s4 =T)

# Rolling episodes
r <- rolling_episodes(date = dates, case_length=14, group_stats = T, display = F, to_s4 =T)

dates # dates

f # fixed episode identifiers

r # rolling episode identifiers
```

In the `fixed episodes` example, records 1 to 3 are assigned to a `window` - eventual episode ID `"E-1"` (Figure 2). In this window, record 1 is the `reference event` (`"(C)"`) and records 2 and 3 are `duplicates` (`"(D)"`) because they are within 15 days (difference of 14 days) of record 1. Record 4 is not within this 15-day period after record 3 and so begins a new window (and epsiode i.e. episode ID `"E-4"`) as its `reference event`. Record 5 is within 15 days of record 4 and so is assinged to the same windone and thus episode (`"E-4"`). This process continues chronologically until all records have been assigned an episode ID.

In the `rolling episodes` example, records 1 to 3 are also assigned to one window - episode `"E-1"` however, unlike the `fixed episode` example, since records 4 and 5 both fall within 15 days (difference of 14 days) of the last `event` (record 3) of the previous `window` (`E-1`), they are folded into the `E1 window` which becomes longer as a result. Since record 4 is the earliest of the two, it's flagged as the `recurrent (R) event` while record 5 is taken as `duplicate`. 

\newline

**Figure 2: `"Fixed"` and `"rolling"` episodes with their respective `case_lenth` and `recurrence_length`**

```{r echo=FALSE, fig.height=3, fig.width=6, message=FALSE, warning=FALSE}
library(tidyr); library(ggplot2)

r_epids <- f_epids <- infections_2[c("rid","pid","date")]

f_epids$epids <- f
r_epids$epids <- r

r_epids$dt_a <- start_point(r_epids$epids@epid_interval)
r_epids$dt_z <- end_point(r_epids$epids@epid_interval)
r_epids$case_nm <- r_epids$epids@case_nm
r_epids$epid <- r_epids$epids@.Data

f_epids$dt_a <- start_point(f_epids$epids@epid_interval)
f_epids$dt_z <- end_point(f_epids$epids@epid_interval)
f_epids$case_nm <- f_epids$epids@case_nm
f_epids$epid <- f_epids$epids@.Data

plot <- bind_rows(
  mutate(r_epids, method="rolling episodes"),
  mutate(f_epids, method="fixed episodes")) %>% 
  mutate(epi=14, recur=14) %>% 
  select(method, rid, epid, date, dt_a, dt_z, epi, recur, case_nm) %>% 
  mutate(epid = paste("EP",epid,sep="")) %>% 
  mutate_at(vars(dt_a, dt_z), funs(dmy(format(.,"%d/%m/%Y")))) 

plot <- plot %>% 
  group_by(method, epid) %>% 
  arrange(date) %>% 
  mutate(
    last_record = ifelse(row_number()==n(),1,0),
    recur_dup = ifelse(case_nm=="Duplicate" & !is.na(case_nm[row_number()+1]) & case_nm[row_number()+1] == "Recurrent", 1,0)
    ) %>% 
  ungroup() %>% 
  mutate(
    dash_range = case_when(
      case_nm=="Case" ~ epi, 
      (case_nm =="Recurrent" & last_record !=1) | (recur_dup ==1) ~ recur,
      TRUE ~ 0
    ), 
    dash_num = ifelse(dash_range==0,"",paste0(dash_range, "-day diff.")),
    dash_range = date + duration(dash_range,"days")
  )

g_area <- unique(select(plot, method, epid, date=dt_a, dt_z)) 
g_area$rid <- max(plot$rid)

ggplot(plot, aes(x=date, y=rid, group=rid, colour=epid)) +
  geom_point() +
  geom_segment(aes(x=date,xend=dash_range,y=rid,yend=rid), linetype=2) +
  geom_text(aes(hjust="right", label=case_nm), nudge_x = -2, nudge_y = .05, show.legend = FALSE, size =3) +
  geom_text(aes(hjust="left", label=dash_num), nudge_x = 2, nudge_y = .18, show.legend = FALSE, size =2) +
  scale_y_continuous("Record ID", breaks = 1:6) +
  scale_x_date("Specimen date", limits = c(dmy("15/03/2019"), dmy("01/07/2019") ), date_breaks = "25 days", date_labels = "%d %b") +
  facet_wrap(~method, scales = "free_y") +
  guides(col = guide_legend(nrow = 1)) +
  theme(
    strip.background = element_rect(fill="transparent"),
    axis.line = element_line(colour = "black"),
    panel.grid = element_blank(),
    legend.position = "none",
    legend.title = element_blank()
  )
```

***If your case definition does not explicitly require a rolling episode, use `fixed_episode()`. It takes less time.***

For `rolling` episodes, it may be useful to imagine the `windows` as mini-`episodes` that will eventually be collapsed into one main `episode` should they overlap. Each mini-episode is either a `case window` or `recurrence window` and will have one `event` flagged as the `case` or `recurrent event` respectively. Here I say 'flagged' and not `reference event` because by default `recurrent events` are not `reference events`. Strictly speaking, the `reference event` for `recurrence windows` is the **last** `event` from the previous `window` and is where the `recurrence_length` starts from. In the example above, that is record 3 not 4. 

<a id="case_assignment"></a> 

## Making a case definition
Manipulating most arguments in `fixed_episodes()`, `rolling_episodes()` and `episode_group()` affects which `events` are taken as the `case` and `recurrent event` and this ultimately allows you apply a variety of case definitions to your datasets. This section covers the main parts of this process and which behaviours you can control or change.  

### Reference events
From `diyar v0.1.0`, you can use the `recurrence_from_last` argument to specify that the `reference event` for a `recurrence window` should be the **first** `event` from the previous `window` and not the **last** which is the default option. This means that after flagging a `recurrent event`, the `recurrence window` is re-calculated from it. This new option is only really useful if your `case_length` and `recurrence_length` are different. If they are the same (which is also the default behaviour), you'll have essentially created a `fixed episode`. See a demonstration of this below.

```{r message=FALSE, warning=FALSE}
df <- c("01/04/2019", "11/04/2019", "16/04/2019","21/04/2019", "07/05/2019")
df <- data.frame(date= as.Date(df, "%d/%m/%Y"))
df$f1 <- fixed_episodes(df$date, case_length = 14, to_s4 = T, display = F)
df$r1 <- rolling_episodes(df$date, case_length = 14, recurrence_from_last = F, 
                          to_s4 = T, display = F)
df$r2 <- rolling_episodes(df$date, case_length = 14, recurrence_length = 16, 
                          recurrence_from_last = F, to_s4 = T, display = F)
df$r3 <- rolling_episodes(df$date, case_length = 14, recurrence_length = 16, 
                          recurrence_from_last = T, to_s4 = T, display = F)

df
```


### Case window for both case and recurrent events
From `diyar v0.1.0`, you can use the `case_for_recurrence` argument to specify that both `case` and `recurrence events` should have a `case window`. The default behaviour is that only `case events` have a `case window`. See a demonstration of this below. 

```{r message=FALSE, warning=FALSE}
df <- c("01/04/2019", "11/04/2019", "16/04/2019","21/04/2019","25/04/2019", "07/05/2019")
df <- data.frame(date= as.Date(df, "%d/%m/%Y"))

df$r4 <- rolling_episodes(df$date, case_length = 10, case_for_recurrence = F, 
                          to_s4 = T, display = F)
df$r5 <- rolling_episodes(df$date, case_length = 10, case_for_recurrence = T, 
                          to_s4 = T, display = F)

df
```

Notice that all `events` have been assigned to the same `episode` in both examples but the second one has 1 less `recurrent event`.

### Number of recurrence periods and episodes
You can choose how many times to check for `episodes` using `episode_max`. When `episode_max` is reached, any `event` not yet grouped is assigned a unique episode ID, making them unique `cases`.

```{r warning=FALSE, message=FALSE}
data("infections_3");
dbs <- infections_3[c("pid","date")]; dbs

# Maximum of one fixed episode grouping per strata
dbs$eps_1 <- fixed_episodes(strata = dbs$pid, date = dbs$date, case_length = 3, display = FALSE, episodes_max = 1, to_s4 = TRUE)

# Maximum of one rolling episode grouping per strata
dbs$eps_2 <- rolling_episodes(strata = dbs$pid, date = dbs$date, case_length = 3, display = FALSE, episodes_max = 1, to_s4 = TRUE)

# Maximum of two fixed episodes grouping per strata
dbs$eps_3 <- fixed_episodes(strata = dbs$pid, date = dbs$date, case_length = 3, display = FALSE, episodes_max = 2, to_s4 = TRUE)

dbs

```

Similarly, you can choose how many times to check for `recurrent events` i.e. how many `periods of recurrence` your case definition permits. You do this with `rolls_max`. The default is `Inf` i.e. check until there are no more `events` within the `recurrence period` of the `reference event` from the previous `window`. See below.

```{r warning=FALSE, message=FALSE}
# Infinite recurrence periods per episode (Default)
dbs$eps_4 <- rolling_episodes(strata = dbs$pid, date =dbs$date, case_length = 2,display = FALSE, to_s4 = TRUE)

# Maximum of one recurrence period per episode
dbs$eps_5 <- rolling_episodes(strata = dbs$pid, date =dbs$date, case_length = 2,display = FALSE, 
                              rolls_max = 1, to_s4 = TRUE)

# Maximum of two recurrence periods per episode
dbs$eps_6 <- rolling_episodes(strata = dbs$pid, date =dbs$date, case_length = 2,display = FALSE, 
                              rolls_max = 2, to_s4 = TRUE)

dbs
```

Note that if `case_for_recurrence` is `TRUE`, after checking for `recurrence` in the last `recurrence period` as specified by `rolls_max`, the function will still check for `duplicates` within the `case window` of the last `recurrent event`.

### Chronological order of events
By default, episode grouping begins at the **earliest** `event` and proceeds to the most recent one, making the earliest `event` the `case`. The opposite of this behaviour is to begin episode grouping at the **most recent** `event` (making that the `case`) and then proceed backwards in time. These behaviours are determined by `from_last`.

```{r message=FALSE, warning=FALSE}
dbs <- infections_2[c("date")]; dbs

# Episode grouping in chronological order
dbs$forward <- fixed_episodes(date=dbs$date, case_length= 14,
                              group_stats = TRUE, display = FALSE, to_s4=TRUE)

# Episode grouping in reverse chronological order
dbs$backward <- fixed_episodes(date=dbs$date, case_length= 14, group_stats = TRUE, display = FALSE,
                               from_last=TRUE, to_s4=TRUE)

dbs[c("forward","backward")]
```

<a id ="custom_sort"></a>

### User defined case assignment
Aside from the chronological order of `events`, you can have a specific preference for which `event` episode grouping will start from. This preference is supplied to `custom_sort`. In `fixed_episodes()` and `rolling_episodes()`, `custom_sort` should be a vector whose values when sorted in ascending order specifies the desired preference. For example, `events` with a `custom_sort` value of `1` will be preferentially taken as the start of an `episode` over one with a value of `2`. This is prioritised over the chronological order of those records. See the example below.

```{r message=FALSE, warning=FALSE}
dates <- c("01/04/2019", "05/04/2019", "07/04/2019")
dates <- as.Date(dates,"%d/%m/%Y")
user_sort <- c(2,1,2)

dates

# preference determined by from_last 
fixed_episodes(date=dates, case_length=6, to_s4=TRUE, display=FALSE, group_stats = TRUE)

# user defined preference via custom sort is prioritised before from_last 
fixed_episodes(date=dates, case_length=6, to_s4=TRUE, custom_sort = user_sort, display=FALSE, group_stats = TRUE)

# user defined preference via custom sort is prioritised before from_last. 
# Duplicates are flagged from both directions
fixed_episodes(date=dates, case_length=6, to_s4=TRUE, custom_sort = user_sort, display=FALSE, 
               bi_direction = TRUE, group_stats = TRUE)

```

In the second example, even though the second record occurred after the first, episode grouping began at the second one. This was because the `custom_sort` value (`user_sort`) for the second record was lower than that of the first.

A consequence of using `custom_sort` this way is that record 1 is not grouped together with record 2 even though it's within the `case_length` of record 2. This is because duplicates are tracked in one direction determined by `from_last`. To track duplicates from both directions use `bi_direction` as shown in the third example.   

Note that examples 1 and 3 results in the same number of `duplicates` (and `episodes`) but different `cases` - records 1 and 2 respectively.

***`custom_sort` will follow `R` standard sort behaviour. For example, a `factor` will sort on its levels not the descriptive label.***

For a practical example, see a case definition where *E. coli* urinary tract infections (UTI) are considered precursors to *E. coli* bloodstream infections (BSI). This means that `episodes` need to be created in such a way that; if there are UTI and BSI records within the same `case_length`, the UTI record will be taken as the `case`. 

```{r message=FALSE, warning=FALSE}
dbs <- infections_2[c("date","infx")]
dbs$infx <- gsub("E. coli ","",dbs$infx)
dbs$infx[c(2,5)] <- "UTI"

dbs

dbs$epids_1 <- fixed_episodes(date=dbs$date, case_length=14, 
                custom_sort = dbs$infx, display = FALSE, to_s4 = TRUE)

dbs$infx_f <- factor(dbs$infx, levels = c("UTI","BSI"))

dbs$epids_2 <- fixed_episodes(date=dbs$date, case_length=14, 
                custom_sort = dbs$infx_f, display = FALSE, to_s4 = TRUE)

dbs$epids_3 <- fixed_episodes(date=dbs$date, case_length=14, 
                custom_sort = dbs$infx_f, display = FALSE, to_s4 = TRUE, bi_direction = TRUE)

dbs
```

In `epids_2`, after changing the sort preference using factor levels (`infx_f`), record 1 (*E. coli* BSI)  and record 2 (*E. coli* UTI) are no longer part of the same `episode`. This is because record 2, is now the `reference event` where episode grouping began, and since record 1 occurred before record 2, they are not grouped together. `epids_3` is episode grouping when `bi_direction` is used.

***In `episode_group()`, you can implement `custom_sort` in levels. You'll need to create a column for each level. The column names are then supplied to `custom_sort` in the required order (level)***

<a id="stratified_grouping"></a>

## Stratified episode grouping
Episode grouping can be done separately for different subsets (`strata`) of a dataset. Examples of a `strata` could be patient IDs, pathogen, source of infection or any combination of these. `Episodes` will be limited to each `strata` however, `episodes` from different `strata` can have a different `case_length` and/or `recurrence_length`.

**`record_group()` is useful for creating group identifiers which can be used as a `strata`. See [record group](record_group.html) for further details.**

As an example, using the `infections` dataset, a case definition may specify the following;

- UTI and BSI records are considered different `episodes` regardless of when they occur
- UTI has a `case_length` of 8 days and `recurrence period` of 31 days
- BSI has a `case_length` of 15 days and no `recurrence period`

In the example below, adding `infection` to the `strata` argument means that `"UTI"` and `"BSI"` records will not be in the same `episode`. Furthermore, the `case_length` and `recurrence_length` for each will be different as specified in the `epi` and `recur` columns respectively 
```{r warning=FALSE}
data(infections)
dbs <- infections[c("date","infection")]
dbs <- dbs[dbs$infection%in% c("UTI","BSI"),]
dbs$epi <- ifelse(dbs$infection=="UTI", 7, 14)
dbs$recur <- ifelse(dbs$infection=="UTI", 30, 0)

dbs$epids <- rolling_episodes(date=dbs$date, case_length =dbs$epi, to_s4 =TRUE,
                            recurrence_length = dbs$recur, display = FALSE, group_stats = TRUE)

dbs
```

<a id="sub_strata"></a>

### Sub-strata
A sub-strata is created when records within a `strata` have a different `case_length` or `recurrence_length`. The case definition below demonstrates how you can take advantage of this.

- UTI and BSI records are different episodes regardless of when they occur. 
- UTIs have a `case_length` of 8 days and recurrence period of 31 days
- BSIs have a `case_length` of 15 days if not treated **OR** a `case_length` of 5 days if treated. In both situations there is no recurrence period.
- Respiratory tract infections (RTI) have a `case_length` of 29 days and recurrence period of 6 days

In this example, whether or not the infection is treated should be viewed as the sub-strata, and the source of infection as the `strata`.

```{r warning=FALSE}
data("infections_4"); 
dbs <- infections_4

dbs$epids <- episode_group(infections_4, sn=rid, strata=c(pid, organism, source), date=date, 
                case_length =epi, episode_type = "rolling", recurrence_length = recur,
                display = FALSE, to_s4 = TRUE)

dbs
```

There are a few things to note with stratified grouping;

- Unless required, `case_length` and `recurrence_length` should be consistent across each `strata` otherwise, you'll inadvertently create a sub-strata
- Episode grouping with and without a sub-strata are different and could lead to different results
- Using sub-strata is not the same as adding that sub-strata to the `strata` argument. In the example above, adding `treated` to `strata` will group treated infections separately from untreated infections. While this could be the desired outcome depending on your case definition, the case definition above did not required treated and untreated infections to be grouped separately, only that the treated infections last longer.

Stratified grouping is the same as doing a separate analysis for each subset (`strata`) of the dataset.

<a id="interval_grouping"></a>

## Interval grouping
Here we discuss the process of grouping `periods of events` into `episodes`. Each `event period` is essentially a record with a `start_point()` and `end_point()` in time. For the purpose of episode grouping, these `event periods` are created as `number_line()` objects and supplied to the `date` argument. Overlapping `event periods` are merged into longer period.

Below are simple examples;

```{r message=FALSE, warning=FALSE}
dates <- as.Date(c("01/04/2019", "05/04/2019"), "%d/%M/%Y")
dates

# A 10-day period from each date
periods <- number_line(dates, dates + 10)
periods

# Grouping events
fixed_episodes(date=dates, case_length=30, to_s4=TRUE, display=FALSE, group_stat=TRUE)

# Grouping periods
fixed_episodes(date=periods, case_length=30, to_s4=TRUE, display=FALSE, group_stat=TRUE)
```

For a practical example, below are periods of hospital stay which have been grouped into `episodes`. This is different from grouping the actual admission or discharge events.

```{r message=FALSE, warning=FALSE}
hos_admin <- diyar::hospital_admissions

hos_admin$admin_period <- number_line(hos_admin$admin_dt, hos_admin$discharge_dt)

hos_admin

# Grouping the actual admissions into episodes
fixed_episodes(date=hos_admin$admin_dt, sn=hos_admin$rd_id, case_length=0, 
                display=FALSE, to_s4=TRUE, group_stats=TRUE)

# Grouping the periods of stay (admission -> discharge)
fixed_episodes(date=hos_admin$admin_period, sn=hos_admin$rd_id, case_length = 0, 
                display=FALSE, to_s4=TRUE, group_stats=TRUE)

```

There are 6 ways `event periods` can overlap (`overlap_methods`). These are `"exact"`, `"across"`, `"inbetween"`, `"chain"`, `"aligns_start"` and `"aligns_end"`. Only `event periods` that overlap by specified methods will be grouped into the same `episode`. You can use any combination of the 6 methods but the default option is to use all 6. See below for a demonstration of this.

```{r warning=FALSE}
# wrapper function to use with lapply
epi_grp_func <- function(x){
  fixed_episodes(date=hos_admin$admin_period, 
                 sn=hos_admin$rd_id, 
                 case_length = 0, 
                 overlap_methods = x, 
                 display = FALSE, 
                 to_s4 = TRUE, 
                 group_stats = TRUE)
}

# Methods 
methods <- list(
  # Identical intervals
  exact = "exact",
  # Overlapping intervals
  across= "across",
  # Intervals with aligned start points
  aligns_start = "aligns_start",
  # Intervals with aligned end points
  aligns_end = "aligns_end",
  # Chained intervals
  chain = "chain",
  # Intervals occurring completely within others
  inbetween = "inbetween",
  # Chained intervals and those occurring completely within others
  cb1 = "chain|inbetween",
  # Chained intervals, identical intervals and those occurring completely within others
  cb2 = "exact|chain|inbetween",
  # Chained intervals, overlapping intervals and those with aligned end point
  cb3 = "across|chain|aligns_end"
)

epids <- lapply(methods, epi_grp_func)
names(epids) <- names(methods)

# Results
epids["chain"]

epids["cb2"]

# See all results in Figure 2 below
```

**Figure 2: Different options for `overlap_methods`**
```{r echo=FALSE, fig.height=5.8, fig.width=8, message=FALSE, warning=FALSE}
clean_func <- function(x, e){
  k <- cbind(hos_admin, diyar::to_df(x))
  k <- k[k$epid_total >1,]
  k <- left_join(
    rename(k[k$case_nm=="Case", c("epid","admin_period")], a = admin_period),
    k, by="epid"
  )

  k$om <- overlap_method(k$admin_period, k$a)
  k <- select(k, sn, admin_dt, discharge_dt, epid, case_nm, om)
  k$len_dt <- k$discharge_dt + e
  k$e_len <- k$discharge_dt - k$admin_dt
  k <- gather(k, var, val, -c(epid, case_nm, om, sn, e_len))
  k$sn <- as.character(k$sn)
  k$epid <- as.character(k$epid)
  k
}

epids_df <- lapply(epids, function(x){
  clean_func(x, 0)
})


epids_db <- NULL
for(i in 1:length(epids_df)){
  epids_df[[i]]$grp <- names(epids_df[i])
  epids_db <- rbind(epids_db, epids_df[[i]])
}

epids_db$label <- ifelse(epids_db$var!="admin_dt", "", epids_db$case_nm)
epids_db$col <- paste(epids_db$grp, epids_db$epid, sep="_")

epids_db$grp_l <- factor(epids_db$grp, levels = c("exact", "across","aligns_start","aligns_end","chain", "inbetween", "cb1", "cb2", "cb3"), labels = c("exact", "across","aligns_start","aligns_end","chain", "inbetween", "chain or inbetween", "chain, inbetween or exact", "chain, across or aligns_end"))

ggplot(epids_db[epids_db$var!="len_dt",], aes(x=val, y=sn, group=sn, colour=col)) +
  geom_line(aes(colour=col)) +
  geom_point() +
  geom_text(aes(hjust="right", label=label), nudge_x = -2, nudge_y = .05, show.legend = FALSE, size =3) +
  # geom_text(aes(hjust="left", label=match_cd), nudge_x = -1.5, nudge_y = .22, show.legend = FALSE, size=3) +
  scale_y_discrete("Record ID") +
  scale_x_date("Admitted period", limits = c(dmy("15/12/2018"), dmy("10/02/2019")), date_breaks = "20 days", date_labels = "%d %b") +
  guides(col = guide_legend(nrow = 3)) +
  facet_wrap(~grp_l, scales = "free_y") +
  theme(
    strip.background = element_rect(fill="transparent"),
    axis.line = element_line(colour = "black"),
    panel.grid = element_blank(),
    legend.position="none"
  )


```

`case_length` in interval grouping works in a similar manner. See Figure 3 below (grouped `episodes` only).

```{r warning=FALSE, include=FALSE}
epi_grp_func2 <- function(f){
  fixed_episodes(date=hos_admin$admin_period, 
                 sn=hos_admin$rd_id, 
                 case_length = f, 
                 overlap_methods = "inbetween", 
                 display = FALSE, 
                 to_s4 = TRUE, 
                 group_stats = TRUE)
}


epids2 <- lapply(29, epi_grp_func2) 
epids_df2 <- lapply(epids2, function(x){
  clean_func(x, 29)
})

epids3 <- lapply(-1, epi_grp_func2) 
epids_df3 <- lapply(epids3, function(x){
  clean_func(x, -1)
})

epids4 <- lapply(-3, epi_grp_func2) 
epids_df4 <- lapply(epids4, function(x){
  clean_func(x, -3)
})

epids_df2[2] <- epids_df4[1]  
epids_df2[3] <- epids_df3[1]

names(epids_df2) <- c("a","b","c")
epids_db2 <- NULL
for(i in 1:length(epids_df2)){
  epids_df2[[i]]$grp <- names(epids_df2[i])
  epids_db2 <- rbind(epids_db2, epids_df2[[i]])
}

epids_db2$label <- ifelse(epids_db2$var!="admin_dt", "", epids_db2$case_nm)
epids_db2$col <- paste(epids_db2$grp, epids_db2$epid, sep="_")

epids_db2$grp_l <- factor(epids_db2$grp, levels = c("a","c","b"), labels = c("inbetween: 30-day case_length","inbetween: -1-day case_length","inbetween: -4-day case_length"))

```

**Figure 3: Positive and negative `case_length` in interval grouping**
```{r echo=FALSE, fig.height=3, fig.width=8, message=FALSE, warning=FALSE}
ggplot(epids_db2[epids_db2$var!="len_dt",], aes(x=val, y=sn, group=sn, colour=col)) +
  geom_line(data=epids_db2[!(epids_db2$case_nm=="Case" & epids_db2$grp %in% c("b","c")) & epids_db2$var!="len_dt",], aes(colour=col), linetype=1) +
  geom_line(data=epids_db2[epids_db2$case_nm=="Case" & epids_db2$var!="discharge_dt" & epids_db2$grp=="a",], aes(colour=col), linetype=2) +
  geom_line(data=epids_db2[epids_db2$case_nm=="Case" & epids_db2$var!="discharge_dt" & epids_db2$grp %in% c("b","c"),], aes(colour=col), linetype=1) +
  geom_point() +
  geom_text(aes(hjust="right", label=label), nudge_x = -2, nudge_y = .05, show.legend = FALSE, size =3) +
  # geom_text(aes(hjust="left", label=match_cd), nudge_x = -1.5, nudge_y = .22, show.legend = FALSE, size=3) +
  scale_y_discrete("Record ID") +
  scale_x_date("Admitted period", limits = c(dmy("15/12/2018"), dmy("10/02/2019")), date_breaks = "20 days", date_labels = "%d %b") +
  guides(col = guide_legend(nrow = 3)) +
  facet_wrap(~grp_l) +
  theme(
    strip.background = element_rect(fill="transparent"),
    axis.line = element_line(colour = "black"),
    panel.grid = element_blank(),
    legend.position="none"
  )
```

<a id="tips"></a>

## Useful ways of using these functions
### Episode grouping across other units of time
In the examples above, episode grouping was done by days (`episode_unit`). However, it can be done by other units of time e.g. hours, days or weeks. Acceptable options are those supported by `lubridate's duration()` function. Below is an example of episode grouping by the hour.

```{r warning=FALSE, message=FALSE}
data("hourly_data"); dbs <- hourly_data

dbs[c("datetime", "category")]

rolling_episodes(strata = dbs$category, date = dbs$datetime, case_length = 5,
                 episode_unit = "hours", recurrence_length = 9, group_stats = TRUE, to_s4 = TRUE, display = FALSE)
```

### Limit episode grouping to a subset of the dataframe
For example, with the `hourly_data` dataset, you can decide to exclude `"GP1"` and `"GP2"` records from episode grouping as shown below. Records excluded from episode grouping this way are assigned unique episode IDs.

```{r warning=FALSE, message=FALSE}
dbs <- head(hourly_data[c("datetime","category")], 10)
dbs$subset <- ifelse(dbs$category!="GP3", NA, "group")

dbs$epids <- rolling_episodes(strata= dbs$subset, date = dbs$datetime, case_length = 5, episode_unit = "hours", 
                        recurrence_length = 9, display = TRUE, group_stats = TRUE, to_s4 = TRUE)

dbs
```

### Use a `strata` from `record_group()`
You can used `pid` objects from `record_group()` as a `strata`.

```{r warning=FALSE, message=FALSE}
data(infections) 

dbs <- infections[c("date","infection")]; dbs

# familiar unique record ids for reference - optional
dbs$rd_id <- c(640,17,58,21,130,79,45,300,40,13,31)

# strata based on matching sources of infection
dbs$pids <- record_group(dbs, sn = rd_id,  criteria = infection, to_s4 = TRUE, display = FALSE)

# stratified grouping 
dbs$epids <- fixed_episodes(sn = dbs$rd_id, date = dbs$date, strata = dbs$pids, 
                             to_s4 = TRUE, display = FALSE, group_stats = TRUE, case_length = 10)

dbs
```

### Use `numeric` values for the `date` argument 
`date` and `datetime` objects are fundamentally numeric values within the context of a reference point (`as.Date(..., origin)`). The episode grouping process ignores this context and instead uses each value as a reference point for others. Therefore, it will allow you use `numeric` values instead of `date` or `datetime` values for the `date` argument. For example, if you use `0-2`, it does not matter what they represent i.e. number of days from a particular date or number of seconds from a particular time. It only matters that `0` is before `1`, which in turn is before `2`. When the functions are used this way, the `episode_unit` argument is ignored.

```{r warning=FALSE, message=FALSE}
vals <- c(8.1,6,12,8.5,12,3,8,15,5,7)

vals

fixed_episodes(vals, case_length = .5, group_stats = T, to_s4 = T, display = F)

fixed_episodes(vals, case_length = 5, group_stats = T, to_s4 = T, display = F)

fixed_episodes(vals, case_length = 100, group_stats = T, to_s4 = T, display = F)
```

# Conclusion
There are a variety of ways to use these function. Before beginning, It's worth reviewing your case definition and its implication on the dataset. In general, the following steps will guide you on how to use them;

1. Work out which columns should be the `strata`
2. Choose whether you need `"fixed"` or `"rolling"` episodes
3. Choose whether you are grouping individual events or a duration of events by supplying a date, datetime or `number_line` object as required. See [interval grouping](#interval_grouping)
4. Choose the required `case_length`, and/or `recurrence_length`. The values should be unique to each `strata` unless you require a [sub-strata](#sub_strata)
5. Change `from_last` to `TRUE` if you want to start episode grouping at the most recent record thereby making it the `"Case"`. Note that this is not the same as starting episode grouping at the earliest record (`from_last` is `FALSE`) and then picking the most recent record in that episode as the `"case"`. See [case assignment](#case_assignment)
6. If you require the `"Case"` to be the earliest or most recent record of a particular type of record, use `custom_sort` in combination with `from_last`. If not, ignore this argument. See [user defined case assignment](#custom_sort)
7. If you require episodes to include records on either side of the `"Case"` use `bi_direction`. If not, ignore this argument
8. Determine if you are measuring episodes by the minute, hour or day etc., and set `episode_unit` accordingly. Be sure to supply a `datetime` to the `date` argument if `episode_unit` is less than "days"
