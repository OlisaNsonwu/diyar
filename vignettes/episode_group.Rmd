---
title: "Implementing case definitions for epidemiological analysis in R"
date: "`r format(Sys.Date(), '%d %B %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Implementing case definitions for epidemiological analysis in R}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r include=FALSE}
plot_epid <- diyar:::plot_epid
date <- function(x) as.Date(x, "%d/%m/%Y")
dttm <- function(x) as.POSIXct(x, "UTC",format="%d/%m/%Y %H:%M:%S")
```

#Introduction
In epidemiological analyses, an exact distinction between temporal events is not always possible. Therefore, static but reasonable cut-off are used to distinguish between events. This is an important aspect of a case definition. For example, it's often important to distinguish between repeat positive infection results during a pathogen's incubation period. Another example, is distinguishing infections by a single pathogen from those by multiple pathogens over a particular periods. 

`episodes()` provide simple but flexible ways of doing this. They group events into temporal episodes which then allows for easy deduplication or a sub-analysis within each episode.

`fixed_episodes()` and `rolling_episodes()` are wrapper functions of `episodes()`. They exist for convenience and to support code from earlier versions of `diyar (< v0.2.0)`.

# Uses

These functions can implement a variety of case definitions. For example, they can group events into;

+ episodes where the events occurred at points in time e.g. medical diagnoses or traffic incidents
+ episodes where the events occurred over periods in time e.g. hospital admission or incubation periods. See [interval grouping](#interval_grouping)
+ episodes where the events are known to recur
+ episodes where certain type of events are assumed to be the index (reference) events. See ["user defined index events"](#custom_sort)
+ episodes with different durations depending on the type of event. See [stratified episode tracking](#stratified_grouping)

# Overview
An episode as produced by `episodes()` is a set of events (dated records) within a specified period. Each episode begins with an index event and may contain duplicate or recurrent events. Two main types of episodes can be produced;

+ `"fixed"` episodes that do not include periods of recurrence
+ `"rolling"` episodes which can include periods of recurrence

# Implementation

<a id= "episode_grouping"></a>

## Episodes, windows, case lengths and recurrence periods

Before we begin, let's go over some terms which will pop up now and again. 

+ `event` -  a dated record i.e. single point in time.
+ `event period` - `events` with a known duration i.e. start and end points in time.
+ `reference event/period` - index `event` or `event period`
+ `"lengths"` -  temporal cut-offs for distinguishing `events`
    + `case_length` - cut-off period distinguishing an `event` from another.
    + `recurrence_length` - cut-off period distinguishing an `event` from a recurrence of the same `event`.
+ `window` - all `events` within the same `case_length` **OR** `recurrence_length`
    + `case window` - all `events` within a `case_length`
    + `recurrence window` - all `events` within a `recurrence_length`
+ `episode` - all `event` within the same cut-off - `case_length` **AND** `recurrence_length` i.e. every overlapping `window`.
+ `case event` - index `event` for the entire `episode`
+ `recurrent event` - first `event` within a `recurrence_length`
+ `duplicate event` - repeat `events` of the `case` or `recurrent events`
+ `episode tracking/grouping` - the process of grouping `events` into `episodes`.

In `"fixed" episodes`, each `window` forms a separate `episode`. However, in `"rolling" episodes`, if two or more `windows` overlap, they are collapsed into a larger `window`. This means that the `episode` is still on-going or has recurred. As a result, every `event` belonging to both `windows` are now considered part of the same `"rolling" episode`.

## How to apply a case definition
### epid objects
Firstly, let's go through what `episodes` look like in `diyar`. They are stored as `epid` objects (`S4` object class). An `epid` object is an `episode` identifier with `slots` for additional information about each `episode`. 

```{r message=FALSE, warning=FALSE, include=FALSE}
library(diyar)
ds <- c("01/04/2019", "06/04/2019", "10/04/2019", "11/04/2019")
ds <- as.Date(ds, "%d/%m/%Y")
ep <- rolling_episodes(date = ds, case_length = 6, group_stats = T, data_source = c("DS1","DS1","DS3", "DS1"))
```

 
```{r echo=FALSE, message=FALSE, warning=FALSE}
df <- data.frame(events =ds, data_source = c("DS1","DS1","DS3", "DS1"), epid= ep)
df
```

For an `epid` object created from a set of `events` sourced from different `data_sources`, the following are displayed (`format.epid`);

+ ``r substr(format(ep[1]),1,3) `` - `episode` identifier
+ ``r substr(format(ep[1]),5,28) `` - `episode` duration. *Only shown if `group_stats` is `TRUE`*
+ ``r paste0(unique(substr(format(ep),30,33)), collapse="/") `` - type of event i.e. `case`, `duplicate` and `recurrent events` respectively

*See `?episodes` for further details.*

*to_df() is a transforms `epid` objects `data.frames`.*

```{r echo=FALSE, message=FALSE, warning=FALSE}
cat("to_df(`epid`)")
to_df(df$ep)
```

### cut-offs - case and recurrence lengths 
Your first consideration should be a cut-off point to distinguish between `episodes`. This is referred to as the `case_length`. A `case_length` of `5` means that; repeat `events` within `6 days (Time difference of 5 days)` of the `reference event` are considered `duplicates` of the `reference event`. See below.

```{r message=FALSE, warning=FALSE}
library(diyar)

# Events
ds <- c("01/04/2019", "03/04/2019", "13/04/2019","16/04/2019", "18/04/2019")
ds <- data.frame(date= as.Date(ds, "%d/%m/%Y"))
ds$date
```

**Figure 1a: fixed episodes**
```{r warning=FALSE}
# 6-day (5-day difference) episodes - fixed episodes
ds$f1 <- fixed_episodes(date = ds$date, case_length = 5, display = "none")

ds$f1
```

```{r echo=FALSE, fig.height=4, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = ds$f1, date= ds$date, case_length = 5)
```

Alternatively, you can specify a cut-off range instead. For example, a `case_length` of ``r format(number_line(12, 16))`` means that; repeat `events` within `13` and `17` days after the `reference event` are considered `duplicates` of the `reference event`. 

*Ranges are created with `number_line()`. See the [number line vignette](number_line.html).*

**Figure 1b: fixed episodes with a cut-off range**

```{r warning=FALSE}
rng <- number_line(12, 16); rng
ds$f2 <- fixed_episodes(date = ds$date, case_length = rng, display = "none")

ds$f2
```

```{r echo=FALSE, fig.height=4, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = ds$f2, date= ds$date, case_length = rng)
```

As above, `events` before the `13th` are skipped. Changing `skip_if_b4_lengths` to `FALSE` will ensure that they are not skipped.

**Figure 1c: fixed episodes where events before the the cut-off range are not skipped**

```{r warning=FALSE}
ds$f3 <- fixed_episodes(date = ds$date, case_length = rng, skip_if_b4_lengths = F, 
                        display = "none")

ds$f3
```

<a id="case_assignment"></a> 

```{r echo=FALSE, fig.height=4, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = ds$f3, date= ds$date, case_length = rng)
```

Finally, you can use multiple `case_lengths` by supplying these as a `list`. For example, a `case_length` of `list(5, number_line(15, 17))` means that; repeat events within `6 days`, and within `16` and `18 days` after the index event are considered duplicates.

**Figure 1d: fixed episodes with multiple `case_lengths`**

```{r warning=FALSE}
rngs <- list(5, number_line(15, 17))
ds$f4 <- fixed_episodes(date = ds$date, case_length = rngs, skip_if_b4_lengths = F, 
                        display = "none")

ds$f4
```

### Reference events
Your next consideration should be the index (`referenc`) `events`. It's common practice for the index `event` to be one which occurred first. However, there are times when the most recent `event` will be more appropriate. For example, if a deceased patient died after a series of positive infection results, the most recent result could be of greater interest.

The first approach is the default behaviour for `epsiodes()`. However, by changing the `from_last` argument to `TRUE`, `episode tracking` will begin at the most recent `event` and proceed backwards in time.

**Figure 2: fixed episodes where episode tracking was backwards in time**

```{r warning=FALSE}
ds$f4 <- fixed_episodes(date = ds$date, case_length = 5, from_last = T,
                        display = "none")

ds$f4
```

```{r echo=FALSE, fig.height=4, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = ds$f4, date= ds$date, case_length = 5, from_last = T)
```

<a id ="custom_sort"></a>

#### User defined reference
There can be situations when the type of `event`, rather than their chronological position, is more relevant to determining an index `event`. For example, when tracking patients with positive infection results for; human immunodeficiency virus (HIV), hepatitis B virus (HBV) and *Mycobacterium tuberculosis* (MyCt), you may want to track concurrent infections beginning or ending with the HIV diagnosis. The examples below show how to handle a situation like this.

```{r warning=FALSE}
ds2 <- data.frame(date=  as.Date(c("13/03/2020", "01/04/2020","15/08/2020",
                                   "11/12/2020", "31/12/2020"), "%d/%m/%Y"),
                  diag = c("HBV","HIV","MyCt","HBV", "MyCt"), 
                  stringsAsFactors = F)


# First make the HIV diagnosis the index event 
ds2$user_ord <- ifelse(ds2$diag=="HIV", 1,2)

# Then track concurrent infections up to 6 months AFTER the HIV diagnosis
ds2$ep1 <- fixed_episodes(date = ds2$date, custom_sort = ds2$user_ord, data_source = ds2$diag,
                          case_length = 6, episode_unit = "months", display = "none")

# Using `data_source` populates the `epid_dataset` slot of the `epid` object. 
# This is useful when you're working with different datasets
ds2$ep1_ds <- ds2$ep1@epid_dataset

# Track preceeding infections up to 6 months BEFORE the HIV diagnosis
ds2$ep2 <- fixed_episodes(date = ds2$date, custom_sort = ds2$user_ord, data_source = ds2$diag,
                          case_length = -6, episode_unit = "months", display = "none")

ds2$ep2_ds <- ds2$ep2@epid_dataset

ds2
```

Notice that in `ep1`, the HIV diagnosis and the HBV diagnosis before it are not grouped into the same `episode`, despite being within 6 months of each other. This also happens with the HIV and MyCt diagnoses in `ep2`. This happens because by default, `episode tracking` occurs in one direction of time (`from_last`). If required, you can simultaneously track `events` in both directions i.e. before and after an index `event`. There are 3 ways of doing this;
    + Change `bi_direction` to `TRUE`
    + Supply an applicable cut-off range e.g. `r format(number_line(-6,6))`
    + Supply a list of cut-off ranges e.g. `list(number_line(-6 -0), number_line(0, 6))`

See examples of each method below. 

```{r warning=FALSE}
# Track preceeding and concurrent infections up to 6 months BEFORE OR AFTER the HIV diagnosis

# Method 1a
# Track diagnoses 6 months AFTER the HIV diagnosis.
  # `bi_direction` then makes the function to also check 6 months BEFORE the HIV diagnosis
ds2$ep3a <- fixed_episodes(date = ds2$date, custom_sort = ds2$user_ord, case_length = 6, 
                           bi_direction = T, episode_unit = "months", display = "none")

# Method 1b
# Track diagnoses 6 months BEFORE the HIV diagnosis
  # bi_direction` then makes the function to also check 6 months AFTER the HIV diagnosis
ds2$ep3b <- fixed_episodes(date = ds2$date, custom_sort = ds2$user_ord, case_length = -6,
                           bi_direction = T, episode_unit = "months", 
                           data_source = ds2$diag, display = "none")

# Method 2a
# Track diagnoses 6 months BEFORE or AFTER the HIV diag. 
  # There's no need for `bi_direction`.
rng <- number_line(-6, 6)
ds2$ep4 <- fixed_episodes(date = ds2$date, custom_sort = ds2$user_ord, case_length = rng, 
                          episode_unit = "months", data_source = ds2$diag, display = "none")

# Method 2b
# Track diagnoses within 2-6 months AFTER the HIV diagnosis. 
  #` bi_direction` then makes the function to also check within 2-6 months BEFORE the HIV diagnosis
# Diagnoses before 2 months on either side are skipped as mentioned in the "cut-offs" section
rng2 <- number_line(1, 6)
ds2$ep5 <- fixed_episodes(date = ds2$date, custom_sort = ds2$user_ord, case_length = rng2, 
                          bi_direction =T, episode_unit = "months", display = "none")

# Method 3a
# Track diagnoses within 2-4 months AFTER the HIV diagnosis, AND 
  # between 4 and 6 months
  # bi_direction` then makes the function to also check between 2-4, and 4-6 month BEFORE the HIV diagnosis
rngs <- list(number_line(1, 4), number_line(4, 6)) 
ds2$ep6 <- fixed_episodes(date = ds2$date, custom_sort = ds2$user_ord, case_length = rngs, 
                          bi_direction =T, episode_unit = "months", display = "none")

# Method 3b
# Track diagnoses within 2-4 and 4-6 months BEFORE AND AFTER the HIV diagnosis
  # There's no need for `bi_direction`.
rngs2 <- c(rngs, lapply(rngs, invert_number_line))
rngs2
ds2$ep7 <- fixed_episodes(date = ds2$date, custom_sort = ds2$user_ord, case_length = rngs2, 
                          episode_unit = "months", display = "none")

ds2
```

Ties in `events` with the same level of preference (`custom_sort` values) are broken with their chronological order. This will be either the earliest or most recent `event` depending on `from_last`. Alternatively, you can break such ties with additional levels of `custom_sort`.

Using `infections` - a sample dataset for positive urinary tract infections (UTI), bloodstream infections (BSI) and respiratory tract infections (RTI), we can see examples of `episode tracking` using 2 and 3 levels of `custom_sort`.

```{r warning=FALSE, message=FALSE}
dbf <- infections[c("date", "infection")]

# 3 levels: "UTI" > "BSI" > "RTI"
dbf$c_sort1 <- ifelse(dbf$infection == "UTI", 1, ifelse(dbf$infection == "BSI", 2, 3))
# 2 levels: "UTI" > ("BSI" OR "RTI")
dbf$c_sort2 <- ifelse(dbf$infection == "UTI", 1, 2)
# 2 levels: "BSI" > ("UTI" OR "RTI")
dbf$c_sort3 <- ifelse(dbf$infection == "BSI", 1, 2)

dbf$ep_1 <- fixed_episodes(date = dbf$date, case_length = 15, data_source = dbf$infection, 
                           custom_sort = dbf$c_sort1, display = "none")

dbf$ep_2 <- fixed_episodes(date = dbf$date, case_length = 15, data_source = dbf$infection, 
                           custom_sort = dbf$c_sort2, display = "none")

dbf$ep_3 <- fixed_episodes(date = dbf$date, case_length = 15, data_source = dbf$infection, 
                           custom_sort = dbf$c_sort3, display = "none")

dbf
```

<a id ="recurrence" ><a/> 

### Recurrent events and periods of recurrence
Another important consideration for a case definition should be if `events` recur. For example, if a relapse of the same infection occurs after a successful treatment therapy, it may be important to treat this as the same `episode` of the initial infection. This differs from a `"fixed" episode` where the relapse will be considered a separate `episode`. 

The `recurrence_length` argument, provides the cut-off period for `recurrent events`. For example, a `recurrence_length` of `10` means that; repeat `events` within `11` days of the last `duplicate event` (of the initial index `event`) are considered a recurrence of the index `event`.

*If `recurrence_length` is not supplied, it's assumed to be the same as the `case_length`.*

**Figure 3a: rolling episodes**
```{r warning=FALSE}
# 6-day (5-day difference) episodes with 11-days recurrence periods - rolling episodes
ds$r1 <- rolling_episodes(date = ds$date, case_length = 5, recurrence_length = 10, display = "none")

ds$r1
```

```{r echo=FALSE, fig.height=4, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = ds$r1, date= ds$date, case_length = 5, recurrence_length = 10)
```

Similarly, for `recurrence_length`, you can use a cut-off range. For example, a `recurrence_length` of ``r format(number_line(13, 15))`` means that; repeat `events` between `14` and `16` days after the last `duplicate event` are considered a recurrence of the index `event`. 

**Figure 3b: rolling episodes with a cut-off range**
```{r warning=FALSE}
rng <- number_line(13, 15); rng
ds$r2 <- rolling_episodes(date = ds$date, case_length = 5, recurrence_length = rng, display = "none")

ds$r2
```

```{r echo=FALSE, fig.height=4, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = ds$r2, date= ds$date, case_length = 5, recurrence_length = rng)
```

By default, `events` before the `14th` are skipped. However, as before, you can change that with `skip_if_b4_lengths`. 

**Figure 3c: rolling episodes where events before the the cut-off range are not skipped**
```{r warning=FALSE}
rng <- number_line(13, 15); rng
ds$r3 <- rolling_episodes(date = ds$date, case_length = 5, recurrence_length = rng, 
                          skip_if_b4_lengths = F, display = "none")

ds$r3
```

```{r echo=FALSE, fig.height=4, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = ds$r3, date= ds$date, case_length = 5, recurrence_length = rng)
```

As with `case_length`, you can supply multiple `recurrence_lengths` as a list.

**Figure 3d: rolling episodes with multiple `recurrece_lengths`**
```{r warning=FALSE}
rngs <- list(number_line(13, 14), number_line(15,18)); rngs
ds$r4 <- rolling_episodes(date = ds$date, case_length = 5, recurrence_length = rngs, 
                          skip_if_b4_lengths = F, display = "none")

ds$r4
```

#### Index events for periods of recurrence

Unlike `"fixed" episodes`, each `"rolling"" episode` has at least two index `events` - one for the whole `episode` and one for each period of recurrence. By default, the last `event` of the previous `window` is the index `event` for the next period of recurrence. However, you can change the `recurrence_from_last` argument to `FALSE`, so that the first `event` in the previous window is used instead. See a demonstration of this below.

*If your `case_length` and `recurrence_length` are the same, which is the default behaviour, you'll essentially create a `"fixed" episode`*. 

```{r message=FALSE, warning=FALSE}
df <- c("01/04/2019", "11/04/2019", "16/04/2019","21/04/2019", "07/05/2019")
df <- data.frame(date= as.Date(df, "%d/%m/%Y"))

# 15-day fixed episodes
df$f1 <- fixed_episodes(date = df$date, case_length = 14, display = "none")

# 15-day rolling episodes with 15-day recurrence periods
  # Since the first event is the reference event for the next recurrence window and,
  # the recurrence_length is the same the case_length (14-day difference), 
  # the result will be the same as the 15-day fixed-episode (above) 
df$r1 <- rolling_episodes(date = df$date, case_length = 14, recurrence_from_last = F, 
                          display = "none")

df

# Identical
all(df$f1==df$r1)
```

**Figure 4a: Last event in a window taken as the reference event for the next recurrence window (default)**
```{r message=FALSE, warning=FALSE}
df$r2 <- rolling_episodes(date = df$date, case_length = 14, recurrence_length = 16, display = "none")

df$r2
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = df$r2, date = df$date, case_length =14, recurrence_length = 16)
```

**Figure 4b: First event in a window taken as the reference event for the next recurrence window**
```{r message=FALSE, warning=FALSE}
df$r3 <- rolling_episodes(date = df$date, case_length = 14, recurrence_length = 16, 
                          recurrence_from_last = F, display = "none")

df$r3
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = df$r3, date = df$date, case_length =14, recurrence_length = 16)
```

#### Case windows for both case and recurrent events
You can use the `case_for_recurrence` argument to specify that both `case` and `recurrence events` should have a `case window`. The default behaviour is that only `case events` have a `case window`. See a demonstration of this below. 

*The `wind_id` slot shows the `window` of every `event`, while `wind_nm` shows what type of `window` it is.*

*Example 1*

```{r message=FALSE, warning=FALSE}
df <- c("01/04/2019", "11/04/2019", "16/04/2019","21/04/2019","25/04/2019", "07/05/2019")
df <- data.frame(date= as.Date(df, "%d/%m/%Y"))
```

**Figure 5a: Case windows for case events only (default)**
```{r message=FALSE, warning=FALSE}
df$r4 <- rolling_episodes(date = df$date, case_length = 10, display = "none")

df$r4
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = df$r4, date = df$date, case_length =10, recurrence_length = 10)
```

**Figure 5b: Case windows for case and recurrence events**
```{r message=FALSE, warning=FALSE}
df$r5 <- rolling_episodes(date = df$date, case_length = 10, case_for_recurrence = T)

df$r5
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = df$r5, date = df$date, case_length =10, recurrence_length = 10)
```

*Example 2.*

```{r message=FALSE, warning=FALSE}
date <-  seq.Date(as.Date("01/04/2019", "%d/%m/%Y"), 
                  as.Date("21/04/2019","%d/%m/%Y"), 
                  by="3 day")
# Example 2
df2 <- data.frame(date = date, sn = 1:length(date))
# dates
df2$date
```

**Figure 5c: Case windows for case events only (default)**
```{r message=FALSE, warning=FALSE}
df2$r1 <- rolling_episodes(date = df2$date, case_length = 6, recurrence_length = 4, sn=df2$sn, display = "none")

df2$r1
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = df2$r1, date = df2$date, case_length =6, recurrence_length = 4)
```

**Figure 5d: Case windows for case and recurrence events**
```{r message=FALSE, warning=FALSE}
df2$r2 <- rolling_episodes(date = df2$date, case_length = 6, recurrence_length = 4, 
                           case_for_recurrence = T, sn=df2$sn, display = "none")

df2$r1
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = df2$r2, date = df2$date, case_length =6, recurrence_length = 4)
```

Notice that in the 4 examples, all `events` have been assigned to the same `episode` but the number of `recurrent events` differ.

### Number of recurrence periods and episodes
Some case definitions may only require you to track the first `n`-number of `episodes`, or specify that they only recur `n`-number of times. You can incorporate these requirements into your analyses using `episodes_max` and `rolls_max` (only applicable to `"rolling" episodes`). When each `strata` (see [stratified episode tracking](#stratified_grouping)) of the dataset has the maximum number of `episodes` (`episodes_max`), subsequent `events` are skipped and assigned unique episode IDs. The default option for `episodes_max` is `Inf` i.e. continue tracking `episodes` until every `event` has been grouped into an `episode`. See the examples below.

```{r warning=FALSE, message=FALSE}
data("infections_3");
dbs <- infections_3[c("pid","date")]; 
# dates
dbs$date
```

**Figure 6a: Maximum of one fixed episode per strata**
```{r message=FALSE, warning=FALSE}
dbs$eps_1 <- fixed_episodes(strata = dbs$pid, date = dbs$date, case_length = 3, 
                            episodes_max = 1, display = "none")

dbs$eps_1
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = dbs$eps_1, date = dbs$date, case_length =3)
```

**Figure 6b: Maximum of two fixed episodes per strata**
```{r message=FALSE, warning=FALSE}
dbs$eps_2 <- fixed_episodes(strata = dbs$pid, date = dbs$date, case_length = 3, 
                            episodes_max = 2, display = "none")

dbs$eps_2
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = dbs$eps_2, date = dbs$date, case_length = 3)
```

`rolls_max` is the maximum number of times an `event` can recur. A `"rolling" episode` ends when `rolls_max` is reached. A new one then begins if the number of `episodes` in that `strata` is less than `episode_max`. The default option for `rolls_max` is `Inf` i.e. continue tracking `recurrent events` until there are no more `events` within the `recurrence period` of the `reference event`. See the examples below.

**Figure 6c: Infinite recurrence periods per episode per strata (default)**
```{r message=FALSE, warning=FALSE}
dbs$eps_4 <- rolling_episodes(strata = dbs$pid, date =dbs$date, case_length = 2, 
                              display = "none")

dbs$eps_4
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = dbs$eps_4, date = dbs$date, case_length =2, recurrence_length = 2)
```

**Figure 6d: Maximum of one recurrence period per episode per strata**
```{r message=FALSE, warning=FALSE}
dbs$eps_6 <- rolling_episodes(strata = dbs$pid, date =dbs$date, case_length = 2, 
                              rolls_max = 1, display = "none")

dbs$eps_6
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = dbs$eps_6, date = dbs$date, case_length =2, recurrence_length = 2)
```

Note that if `case_for_recurrence` is `TRUE`, after checking for tracking the last `recurrence period`, the function will also check for `duplicates` within the `case window` of the last `recurrent event`. See below.

**Figure 6e: Maximum of one recurrence period per episode per strata when case_for_recurrence is TRUE**
```{r message=FALSE, warning=FALSE}
dbs$eps_7 <- rolling_episodes(strata = dbs$pid, date =dbs$date, case_length = 2, 
                              rolls_max = 1, case_for_recurrence = T, display = "none")

dbs$eps_7
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = dbs$eps_7, date = dbs$date, case_length =2, recurrence_length = 2)
```

<a id="interval_grouping"></a>

### Interval grouping
Some case definitions can involve `events` that occur over a defined period of time e.g. hospital admissions. `episodes()` track such `event periods` into `episodes`. This type of `episode tracking` is recommended when the end point of an `event` is known. For example, it's near impossible to know the exact point in time an individual diagnosed with the common cold recovers however, it's a reasonable assumption that another diagnosis 3 months after the initial one is not the same infection. For situations like this, the recommend approach is to use the methods we've covered so far. 

In contrast, hospital admissions typically have recorded admission and discharge times or dates, and so interval grouping is recommended for tracking such `events`. This being said, in several situations both approaches can be used interchangeably. See below. 

```{r message=FALSE, warning=FALSE}
# Dates
dates <- seq(as.Date("01/04/2019", "%d/%M/%Y"), as.Date("20/04/2019", "%d/%M/%Y"), "4 days")

# Periods 
periods <- number_line(dates, dates + 4)

dates
periods

# Track fixed episodes from events with a 5 day cut-off 
mth1 <- fixed_episodes(date = dates, case_length = 4, display = "none")

# Track fixed episodes from periods that are 5 days long 
mth2 <- fixed_episodes(date = periods, case_length = 0, display = "none")

# Same results
mth1; mth2

# Track rolling episodes from events using a 5 day cut-off 
mth3 <- rolling_episodes(date = dates, case_length = 4, display = "none")

# Track rolling episode from periods that are 5 days long 
mth4 <- rolling_episodes(date = periods, case_length = 0, display = "none")

# Same results
mth3; mth4
```

In interval grouping, when `case_length` is `0`, `event periods` that overlap with the index `event period` are grouped together as one `episode`. However, if `case_length` is `> 0`, those that overlap with the index `event` and those within `n`-days (or any time unit) after the `end_point()` of the index `event period` are grouped together. See below. 

```{r message=FALSE, warning=FALSE}
hos_admin <- diyar::hospital_admissions
hos_admin$admin_period <- number_line(hos_admin$admin_dt, hos_admin$discharge_dt)

# Hospital stay
hos_admin$admin_period
```

**Figure 7a: Tracking periods of hospital stay (admission -> discharge)**
```{r message=FALSE, warning=FALSE}
hs_epids_a <- fixed_episodes(date=hos_admin$admin_period, case_length = 0, group_stats = T, display = "none")
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = hs_epids_a, date = hos_admin$admin_period, case_length = 0)
```

**Figure 7b: Tracking periods of hospital stay up to 20 days after the first discharge**
```{r message=FALSE, warning=FALSE}
hs_epids_b <- fixed_episodes(date=hos_admin$admin_period, case_length = 20, 
                 group_stats = T, display = "none")
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = hs_epids_b, date = hos_admin$admin_period, case_length = 20)
```

**Figure 7c: Tracking periods of continuous hospital stay i.e. re-admission within 15 days**
```{r message=FALSE, warning=FALSE}
hs_epids_c <- rolling_episodes(date=hos_admin$admin_period, case_length = 0, 
                recurrence_length = 15, group_stats = T, display = "none")
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = hs_epids_c, date = hos_admin$admin_period, case_length = 0, recurrence_length = 15)
```

There are 6 ways `event periods` can overlap (`overlap_methods`). These are `"exact"`, `"across"`, `"inbetween"`, `"chain"`, `"aligns_start"` and `"aligns_end"`. These are covered in more detail in an accompanying [vignette](number_line.html#overlaps). Only `event periods` that overlap by a specified `overlap_method` will be grouped into the same `episode`. You can use any combination of the 6 methods but the default option is to use all 6. See below for a demonstration of this.

*The 6 `overlap_methods` are mutually exclusive.*

*There are 2 convenience methods - `"none"` and `"overlap"`. These are mutually inclusive with the other 6.*

```{r warning=FALSE}
# wrapper function to use with lapply
epi_grp_func <- function(x){
  epids <- fixed_episodes(date=hos_admin$admin_period, 
                 sn=hos_admin$rd_id, 
                 case_length = number_line(
                   -hos_admin$admin_period@.Data,
                   0), 
                 overlap_methods = x,
                 group_stats = T, 
                 include_index_period = F, 
                 display = "none")
  
  # for the prurpose of this demonstration, limit to overlapped periods    
  epids[epids@epid_total>1]
}

# Methods 
methods <- list(
  # Identical intervals
  exact = "exact",
  # Overlapping intervals
  across= "across",
  # Intervals with aligned start points
  aligns_start = "aligns_start",
  # Intervals with aligned end points
  aligns_end = "aligns_end",
  # Chained intervals
  chain = "chain",
  # Intervals occurring completely within others
  inbetween = "inbetween",
  # Chained intervals and those occurring completely within others
  cb1 = "chain|inbetween",
  # Chained intervals, identical intervals and those occurring completely within others
  cb2 = "exact|chain|inbetween",
  # Chained intervals, overlapping intervals and those with aligned end point
  cb3 = "across|chain|aligns_end"
)

epids <- lapply(methods, epi_grp_func)
names(epids) <- names(methods)

# Results
epids["chain"]

epids["cb2"]
```

*Only showing `events` grouped into `episodes`*

**Figure 8a: Grouped episodes when considering only "exact" overlap method**
```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
eps <- epids[["exact"]]
plot_epid(epid = eps, 
          date = hos_admin$admin_period[eps@sn], 
          case_length = number_line(-hos_admin$admin_period@.Data[eps@sn],
                                    0))
```

**Figure 8b: Grouped episodes when considering only "chain" overlap method**
```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
eps <- epids[["chain"]]
plot_epid(epid = eps, date = hos_admin$admin_period[eps@sn], 
          case_length = number_line(-hos_admin$admin_period@.Data[eps@sn],
                                    0))
```

**Figure 8c: Grouped episodes when considering "chain" or "inbetween" overlap method**
```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
eps <- epids[["cb1"]]
plot_epid(epid = eps, date = hos_admin$admin_period[eps@sn], 
          case_length = number_line(-hos_admin$admin_period@.Data[eps@sn],
                                    0))
```

#### Case and recurrence lengths in interval grouping

```{r warning=FALSE}
pa <- c("28/03/2019", "01/04/2019", "03/04/2019", "07/04/2019","12/04/2019")
pz <- c("31/03/2019", "10/04/2019", "05/04/2019", "09/04/2019","13/04/2019")

pa <- as.Date(pa, "%d/%m/%Y")
pz <- as.Date(pz, "%d/%m/%Y")

periods <- number_line(pa, pz)
periods

```

As seen earlier,  positive "length" means that; `event periods` overlapping with the index `event period` and those within `n`-days AFTER the `end_point()` of the index `event period` will be grouped into the same `episode`. See another example below.

**Figure 9a: Fixed episodes with a case_length of 6**
```{r message=FALSE, warning=FALSE}
eps_a <- fixed_episodes(date = periods, case_length = 6, group_stats = T, display = "none")

eps_a
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = eps_a, date = periods, case_length = 6)
```

In contrast, a negative "length" means that; only `event periods` within `n`-days BEFORE the   `end_point()` of the index `event period` will be grouped into the same `episode`.

**Figure 9b: Fixed episodes with a case_length of -2**
```{r message=FALSE, warning=FALSE}
eps_b <- fixed_episodes(date = periods, case_length = -2, group_stats = T, display = "none")

eps_b
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = eps_b, date = periods, case_length = -2)
```

By default, overlapping periods that are outside the 2-day periods are also groupped together. This can be changed with `include_index_period`. See below.

**Figure 9c: Fixed episodes with a case_length of -2**
```{r message=FALSE, warning=FALSE}
eps_c <- fixed_episodes(date = periods, case_length =-2, group_stats = T,
                        include_index_period = F, display = "none")

eps_c
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = eps_c, date = periods, case_length = -2)
```

**Figure 9d: Fixed episodes with a case_length of -6**
```{r message=FALSE, warning=FALSE}
eps_d <- fixed_episodes(date = periods, case_length =-6, group_stats = T, display = "none")

eps_d
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = eps_d, date = periods, case_length = -6)
```

<a id= "stratified_grouping"></a>

### Stratified episode tracking
In practice, you'll want to track `episodes` separately for different groups (`strata`) e.g. patients, pathogens, sources of infection or any combination of these. This means that `episodes` from one patient will be different from other patients, or `episodes` of HIV diagnoses will be different those of HBV diagnoses. 

*`episodes` from different `strata` can have a different `case_lengths` and/or `recurrence_lengths`.*

*`record_group()` is useful for creating group identifiers which can then be used as a `strata`. See the [record group vignette](record_group.html) for further details.*

As an example, using the `infections` dataset, a case definition may specify the following;

- UTI and BSI diagnoses are considered different `episodes` regardless of when they occur
- UTI `episodes` have a cut-off of 8 days and a recurrence period of 31 days
- BSI `episodes` have a cut-off of 15 days and no recurrence period

By adding the `infection` column to the `strata` argument, `"UTI"` and `"BSI"` diagnoses will not be grouped together under the same `episode`. Furthermore, the `case_length` and `recurrence_length` for each will be different as specified in the `epi` and `recur` columns respectively.

```{r warning=FALSE}
dbs <- diyar::infections[c("date","infection")]
dbs <- dbs[dbs$infection%in% c("UTI","BSI"),]
dbs$epi <- ifelse(dbs$infection=="UTI", 7, 14)
dbs$recur <- ifelse(dbs$infection=="UTI", 30, 0)

dbs$epids <- rolling_episodes(date=dbs$date, case_length =dbs$epi, to_s4 =TRUE, 
                              strata = dbs$infection, recurrence_length = dbs$recur, 
                              group_stats = TRUE, display = "none")

dbs
```

Stratified grouping is a faster and easier alternative to performing separate analyses for each subset (`strata`) of the dataset. However, if you must perform these separately, I recommend using a familiar `sn` and changing `to_s4` to `FALSE`. The former is so that you can easily link each `episode` back to it's corresponding events, while the latter is because binding `S4` objects in my personal opinion is a pain, so `to_s4 = FALSE` changes the `epid` objects to `data.frames`.

*to_s4() and to_df() are convenience functions to change `epid`, `pid`, `number_line` S4 class objects to `data.frames` and vice versa.*

<a id="sub_strata"></a>

#### Sub-strata
`Sub-strata` are when `events` within the same `strata` have different cut-offs. The case definition below demonstrates how this could be beneficial.

- UTI and BSI diagnoses are considered different `episodes` regardless of when they occur 
- UTI diagnoses have a cut-off of 8 days and a recurrence period of 31 days
- BSI diagnoses have a cut-off of 15 days if not treated but 5 days if `treated`. In both situations there is no recurrence period.
- RTI diagnoses have a cut-off of of 29 days and a recurrence period of 6 days

In this example, whether or not the infection is `treated` should be viewed as the `sub-strata` i.e. in a patient (`strata`), an `episode` is expected to last longer if it's not `treated`. 

```{r warning=FALSE}
dbs <- diyar::infections_4

dbs$epids <- episodes(sn = dbs$rid, strata= paste(dbs$pid, dbs$organism, dbs$source), date= dbs$date,
                case_length = dbs$epi, episode_type = "rolling", recurrence_length = dbs$recur, display = "none")

dbs
```

There are a few things to note with stratified grouping;

- Unless required, `case_length` and `recurrence_length` should be consistent for each `strata` otherwise, you'll inadvertently create a sub-strata
- `Episode grouping` with and without a sub-strata are different and could lead to different results
- Using a `sub-strata` is not the same as adding that `sub-strata` to the `strata` argument. In the example above, adding `treated` to the `strata` argument will group `treated` infections separately from untreated infections. While this could be the desired outcome in certain situations, the case definition above only requires that the `treated` infections last longer.

## Cut down your processing time

Some case definitions are so specific that only certain kinds of `episodes` will be required. In such situations, you can save time by skipping `events` from `episodes` that won't be needed. There are 3 mechanisms to skip such `events`. 

*Skipped `events` are assigned unique episode IDs and their `case_nm` slot is flagged as `"Skipped"`.*

### Skip subsets of the dataset 
You can skip an entire `strata` of the dataset by changing it to `NA`. In the example below, assuming you were not interest in tracking `"GP1"` and `"GP2"` records, you can skip these to save time.

*Changing `display` to `TRUE` shows how many iterations of the grouping process it's taken to complete the entire process.*

```{r warning=FALSE, message=FALSE}
dbs <- head(hourly_data[c("datetime","category")], 10)
dbs$subset <- ifelse(dbs$category!="GP3", NA, "group")

# To skip OR
dbs$epids_a <- rolling_episodes(strata= dbs$subset, date = dbs$datetime, case_length = 5, 
                                episode_unit = "hours", recurrence_length = 9, display = "none")

#   OR

# Not to skip
dbs$epids_b <- rolling_episodes(strata= dbs$category, date = dbs$datetime, case_length = 5, 
                                episode_unit = "hours", recurrence_length = 9, display = "none")

dbs
```

### Skip the nth order (skip order) of custom sort
In a dataset with multiple levels of `custom_sort`, you can skip `episodes` that will begin with the `nth` level (`skip_order`) of the `cust_sort`. A `skip_order` of `1` means that; after every `event` with the first level of your `custom_sort` has been grouped into `episodes`, the tracking process will come to an end.

This is handy when you're grouping `episodes` from rare and common `events`, the rare `events` are the index `events` and it's a hassle to subset the dataset.

```{r warning=FALSE, message=FALSE}
dbf <- dbf[c("date", "infection")]
dbf$c_sort <- ifelse(dbf$infection == "UTI", 1, ifelse(dbf$infection == "BSI", 2, 3))

# Skip episodes that would begin with BSI/UTI records
dbf$ep_a <- fixed_episodes(date = dbf$date, case_length = 15, data_source = dbf$infection, 
                           custom_sort = dbf$c_sort, skip_order = 1, display = "none")
dbf$ep_a_d <- dbf$ep_a@epid_dataset

# Don't skip any episodes
dbf$ep_b <- fixed_episodes(date = dbf$date, case_length = 15, data_source = dbf$infection, 
                           custom_sort = dbf$c_sort, display = "none")
dbf$ep_b_d <- dbf$ep_b@epid_dataset

dbf
```

Notice that in the skipped example `ep_a`, no `episodes` begins with either a `"BSI"` or `"RTI"` record.

### Skip episodes without records from certain data sources
The third mechanism is partly a misnomer because it does not skip `events` but rather ungroups `episodes` after they've already been created. After `episodes` have been created, those that do not contain records from certain `data_sources` can be ungrouped using `data_links`. In such instances, the overall execution time will not be shortened but you'll get an `episode` identifier that's relevant to the `data_sources` you're interested in. However, if a `strata` will not produce `episodes` with the required combination of `data_sources`, that entire `strata` will be skipped. If this happens, the total runtime may be shortened.

```{r warning=FALSE, message=FALSE}
dttm <- function(x) as.POSIXct(x, "UTC",format="%d/%m/%Y %H:%M:%S")
dbg <- data.frame(date = seq.POSIXt(dttm("01/04/2018 00:00:00"), dttm("31/05/2018 00:00:00"),
                                    by="3 days"))
dbg <- head(dbg, 11)
dbg$recurrence <- 2
dbg$case_len <- 6
dbg$dataset <- paste("DS",c(1:3, rep(c(1:2),2), rep(3,4)), sep="")

# Don't skip any
dbg$ep_a <- episodes(date = dbg$date, case_length = dbg$case_len, episode_type ="rolling", 
                          recurrence_length = dbg$recurrence, data_source = dbg$dataset, display = "none")

# Breakup episodes without events from the `DS3` `data_source` 
  # The `DS3` event MUST BE linked to events from other `data_sources`  
dbg$ep_b <- episodes(date = dbg$date, case_length = dbg$case_len, episode_type ="rolling", 
                          recurrence_length = dbg$recurrence, data_source = dbg$dataset, 
                          data_links = "DS3", display = "none")

# Breakup episodes without events from the `DS3` `data_source` 
  # The `DS3` event DOESN'T HAVE to be linked to events from other `data_sources`   
dbg$ep_c <- episodes(date = dbg$date, case_length = dbg$case_len, episode_type ="rolling", 
                          recurrence_length = dbg$recurrence, data_source = dbg$dataset, 
                          data_links = list(g="DS3"), display = "none")

# Breakup episodes without events from the `DS3` `data_source` 
  # The `DS3` event MUST BE linkned to events from the `DS1` `data_source`
dbg$ep_d <- episodes(date = dbg$date, case_length = dbg$case_len, episode_type ="rolling", 
                          recurrence_length = dbg$recurrence, data_source = dbg$dataset, 
                          data_links = list(l=c("DS3","DS1")) , display = "none")

dbg[c("date", "dataset", "ep_a", "ep_b", "ep_c", "ep_d")]
```

<a id="tips"></a>

## Useful ways of using these functions

### Episode grouping in other units of time
`episode grouping` can be done in other units of time (`episode_unit`). Acceptable options are `"seconds"`, `"minutes"`, `"hours"`, `"days"`, `"weeks"`, `"months"` or `"years"`. Below is an example of `episode grouping` by the hour.

```{r warning=FALSE, message=FALSE}
dbs <- diyar::hourly_data

# Each unit is relative to a set number of seconds. 
diyar::episode_unit

# 1-day fixed episodes
fixed_episodes(date = dbs$datetime, case_length = 1, episode_unit = "days", 
               group_stats = TRUE, display = "none")

# 5-hr fixed episodes
fixed_episodes(date = dbs$datetime, case_length = 5, episode_unit = "hours", 
               group_stats = TRUE, display = "none")

# 5-hr rolling episodes
rolling_episodes(date = dbs$datetime, case_length = 5, episode_unit = "hours", 
                 group_stats = TRUE, display = "none")
```

### Use a `strata` from `record_group()`
You can used `pid` objects from `record_group()` as a `strata`.

```{r warning=FALSE, message=FALSE}
dbs <- diyar::infections[c("date","infection")]; dbs

# familiar unique record ids for reference - optional
dbs$rd_id <- c(640,17,58,21,130,79,45,300,40,13,31)

# strata based on matching sources of infection
dbs$pids <- record_group(dbs, sn = rd_id,  criteria = infection, display = "none")

# stratified grouping 
dbs$epids <- fixed_episodes(sn = dbs$rd_id, date = dbs$date, strata = dbs$pids, 
                             to_s4 = TRUE, case_length = 10, display = "none")

dbs
```

### Use numeric values for the date argument 
`date` and `datetime` objects are fundamentally numeric values within the context of a reference point (`as.Date(..., origin)`). The `episode grouping` process ignores this context and instead uses each value as a reference point for others. Therefore, you use `numeric` values instead of `date` or `datetime` values for the `date` argument. For example, if you use `0-2`, it does not matter what they represent i.e. number of days from a particular date or number of seconds from a particular time. It only matters that `0` is before `1`, which in turn is before `2`. When the functions are used this way, the `episode_unit` argument is ignored.

```{r warning=FALSE, message=FALSE}
vals <- c(8.1,6,12,8.5,12,3,8,15,5,7)

vals

fixed_episodes(date = vals, case_length = .5, group_stats = T, display = "none")

fixed_episodes(date = vals, case_length = 5, group_stats = T, display = "none")

fixed_episodes(date = vals, case_length = 100, group_stats = T, display = "none")
```

# Conclusion
There are a variety of ways to use these function. Before beginning, It's worth reviewing your case definition and its implication on the dataset. In general, the following steps can serve as a quick guide on how to use them;

1. Work out the `strata` in your dataset
2. Choose and specify whether you need `"fixed"` or `"rolling"` episodes
3. Choose and specify whether you are grouping individual events or periods of events by supplying a `date`, `datetime` or `number_line` object as required. See [interval grouping](#interval_grouping)
4. Choose and specify the required `case_length`, and/or `recurrence_length`. The values should be unique to each `strata` unless you require a [sub-strata](#sub_strata)
5. Change `from_last` to `TRUE` if you want the index `event` to be the earliest or most recent `event`.
6. If you need the index `event` to be the earliest or most recent event of a particular type of event, use `custom_sort` in combination with `from_last`. If not, ignore this argument. See [user defined case assignment](#custom_sort)
7. If you require `episodes` to include `events` on either side of the index `event`, use `bi_direction` or an applicable `case_length` or `recurrence_length`. If not, ignore this point
8. Determine if you are measuring `episodes` by the minute, hour or day e.t.c., and set `episode_unit` accordingly. Be sure to supply a `datetime` to the `date` argument if `episode_unit` is less than `"days"`.

These functions should prove useful in epidemiological analyses however, it's also applicable to analyses in any field where the aim is to track events into temporal groups.

