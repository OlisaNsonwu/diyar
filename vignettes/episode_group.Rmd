---
title: "Implementing case definitions for epidemiological analysis in R"
date: "`r format(Sys.Date(), '%d %B %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Implementing case definitions for epidemiological analysis in R}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r include=FALSE}
plot_epid <- diyar:::plot_epid
date <- function(x) as.Date(x, "%d/%m/%Y")
dttm <- function(x) as.POSIXct(x, "UTC",format="%d/%m/%Y %H:%M:%S")
```

#Introduction
In epidemiological analyses, an exact distinction between temporal events is not always possible. Therefore, static but reasonable cut-off are used to distinguish between events. This is an important aspect of a case definition. For example, it's often important to distinguish between repeat positive infection results during a pathogen's incubation period. Another example, is distinguishing between infections from a single pathogen and those by multiple pathogens within a certain period in time. 

`fixed_episodes()`, `rolling_episodes()` and `episode_group()` provide simple but flexible ways of doing this. They group events into temporal episodes with an index event. This then allows for easy deduplication or a sub-analysis within each episode.

# Uses

These functions can implement a variety of case definitions. For example, they can group events into;

+ episodes where each event occurred at points in time e.g. medical diagnoses or traffic incidents
+ episodes where each event occurred over periods in time e.g. hospital admission or incubation periods. See [interval grouping](#interval_grouping)
+ episodes where the events are known to recur
+ episodes where certain type of events are taken as index (reference) events. See ["user defined case assignment"](#custom_sort)
+ episodes with different durations depending on the type of event. See [stratified grouping](#stratified_grouping)

# Overview
An episode as produced by `fixed_episodes()`, `rolling_episodes()` or `episode_group()` is a set of events (dated records) within a specified period. Each episode begins with an index event and may contain duplicate or recurrent events. 

+ `fixed_episodes()` - for `"fixed"` episodes that do not include periods of recurrence
+ `rolling_episodes()` - for `"rolling"` episodes which can include periods of recurrence
+ `episode_group()` - the main function behind `fixed_episodes()` and `rolling_episodes()` 

# Implementation

<a id= "episode_grouping"></a>

## Episodes, windows, case lengths and recurrence periods

Before we begin, let's go over some terms which will pop up now and again. 

+ `event` -  a dated record i.e. single point in time
+ `event period` - `events` with a known duration i.e. start and end points in time
+ `reference event/period` - index `event` or `event period`
+ The "lengths" -  cut-off for distinguishing `events`
    + `case_length` - cut-off period distinguishing an `event` from another
    + `recurrence_length` - cut-off period distinguishing an `event` from a recurrence of the same `event`
+ `window` - all `events` within the same `case_length` or `recurrence_length`
    + `case window` - all `events` within a `case_length`
    + `recurrence window` - all `events` within a `recurrence_length`
+ `episode` - all `event` within the same cut-off - `case_length` and `recurrence_length`. Every overlapping `window` forms an `episode`
+ `case event` - index `event` for the entire episode
+ `recurrent event` - first `event` within a `recurrence_length`
+ `duplicate event` - non-index `events` within an `episode`
+ `episode tracking/grouping` - the process of grouping episodes. Begins at the index `event` and proceeds forward or backward in time depending on `from_last`.

In `fixed_episodes()`, a `window` always equates to an `episode`. `events` from a different `window` belongs to a separate `episode`. In `rolling_episodes()`, if two or more `windows` overlap, they are collapsed into a larger `window`, indicating that the `episode` is still on-going or has recurred. As a result, every `event` belonging to both `windows` are now considered part of the same `"rolling episode"`.

## How to apply a case definition
### epid objects
Firstly, let's go through what `episodes` look like in `diyar`. By default, they are stored as `epid` objects (`S4` object class). An `epid` object is an `episode` identifier with `slots` for useful information on each `episode`. 

```{r message=FALSE, warning=FALSE, include=FALSE}
library(diyar)
ds <- c("01/04/2019", "06/04/2019", "10/04/2019", "11/04/2019")
ds <- as.Date(ds, "%d/%m/%Y")
ep <- rolling_episodes(ds, case_length = 6, group_stats = T, data_source = c("DS1","DS1","DS3", "DS1"))
```

 
```{r echo=FALSE, message=FALSE, warning=FALSE}
df <- data.frame(events =ds, data_source = c("DS1","DS1","DS3", "DS1"), epid= ep)
df
```

For an `epid` object created from a set of `events` sourced from different `data_sources`, the displayed (`format.epid`) components are;

+ ``r substr(format(ep[1]),1,3) `` - episode identifier
+ ``r substr(format(ep[1]),5,28) `` - episode duration. *Only shown if `group_stats` is `TRUE`*
+ ``r paste0(unique(substr(format(ep),30,33)), collapse="/") `` - `case`, `duplicate` and `recurrent events` respectively

*See `?fixed_episodes` for the details of every slot, including those not displayed.*

*to_df(`epids`) is a convenient accessor function for every slot in an `epid` object. See below.*

```{r echo=FALSE, message=FALSE, warning=FALSE}
to_df(df$ep)
```

### cut-off - case and recurrence lengths 
Your first consideration should be a cut-off point to distinguish between `episodes`. This is referred to as the `case_length`. A `case_length` of `5` means that; repeat `events` within `6 days (Time difference of 5 days)` of the `reference event` are considered `duplicates` of the `reference event`. See below.

```{r message=FALSE, warning=FALSE}
library(diyar)

# Events
ds <- c("01/04/2019", "03/04/2019", "13/04/2019","16/04/2019", "18/04/2019")
ds <- data.frame(date= as.Date(ds, "%d/%m/%Y"))
ds$date
```

**Figure 1a: fixed episodes**
```{r warning=FALSE}
# 6-day (5-day difference) episodes - fixed episodes
ds$f1 <- fixed_episodes(ds$date, case_length = 5, display = F)

ds$f1
```

```{r echo=FALSE, fig.height=4, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = ds$f1, date= ds$date, case_length = 5)
```

Alternatively, your cut-off can be a specific range. For example, a `case_length` of ``r format(number_line(12, 16))`` means that; repeat `events` within `13` and `17` days after the `reference event` are considered `duplicates` of the `reference event`. 

*Ranges are created by number_line(). See the [number line vignette](number_line.html).*

**Figure 1b: fixed episodes with a cut-off range**

```{r warning=FALSE}
rng <- number_line(12, 16); rng
ds$f2 <- fixed_episodes(ds$date, case_length = rng, display = F)

ds$f2
```

```{r echo=FALSE, fig.height=4, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = ds$f2, date= ds$date, case_length = rng)
```

By default, `events` before the `13th` day are skipped. You can change `skip_if_b4_lengths` to `FALSE`, so that such `events` are not skipped.

**Figure 1c: fixed episodes where events before the the cut-off range are not skipped**

```{r warning=FALSE}
ds$f3 <- fixed_episodes(ds$date, case_length = rng, display = F, skip_if_b4_lengths = F)

ds$f3
```

<a id="case_assignment"></a> 

```{r echo=FALSE, fig.height=4, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = ds$f3, date= ds$date, case_length = rng)
```

### Reference events
Your next consideration should be which `events` will be the index `event` (`reference events`). It's common practice for the earliest `event` to be taken as the `reference event`. However, there are times when the most recent `event` will be more relevant for this. For example, if a deceased patient died after a series of positive infection results, the most recent result could be considered more relevant as a `reference event`.

The first approach is the default behaviour for `fixed_epsiodes()` and `rolling_episodes()`. However, by changing `from_last` to `TRUE`, `episode tracking` will begin at the most recent `event` and proceed backwards in time, making that the `reference event`.

**Figure 2: fixed episodes where episode tracking was backwards in time**

```{r warning=FALSE}
ds$f4 <- fixed_episodes(ds$date, case_length = 5, from_last = T, display = F)

ds$f4
```

```{r echo=FALSE, fig.height=4, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = ds$f4, date= ds$date, case_length = 5, from_last = T)
```

<a id ="custom_sort"></a>

#### User defined reference
There can be situations when the type of `event`, rather than its chronological order, is more relevant in determining an index `event`. For example, when tracking patients with positive infection results for; human immunodeficiency virus (HIV), hepatitis B virus (HBV) and *Mycobacterium tuberculosis* (MyCt), you may want to track concurrent infections beginning or ending with the HIV diagnosis. The examples below show how to handle situations like this.

```{r warning=FALSE}
ds2 <- data.frame(date=  as.Date(c("13/03/2020", "01/04/2020","15/08/2020",
                                   "11/12/2020", "31/12/2020"), "%d/%m/%Y"),
                  diag = c("HBV","HIV","MyCt","HBV", "MyCt"), stringsAsFactors = F)


# First make the HIV diagnosis the index event 
ds2$user_ord <- ifelse(ds2$diag=="HIV", 1,2)

# Then track concurrent infections up to 6 months AFTER the HIV diagnosis
ds2$ep1 <- fixed_episodes(date = ds2$date, custom_sort = ds2$user_ord, data_source = ds2$diag,
                          case_length = 6, episode_unit = "months", display = F)

# Using `data_source` populates the `epid_dataset` slot of the `epid` object. 
# This is useful when you're working with different datasets
ds2$ep1_ds <- ds2$ep1@epid_dataset

# Track preceeding infections up to 6 months BEFORE the HIV diagnosis
ds2$ep2 <- fixed_episodes(date = ds2$date, custom_sort = ds2$user_ord, data_source = ds2$diag,
                          case_length = -6, episode_unit = "months", display = F)

ds2$ep2_ds <- ds2$ep2@epid_dataset

ds2
```

Notice that in `ep1`, the HIV diagnosis and the HBV diagnosis before it are not grouped into the same `episode` despite being within 6 months of each other. This also happens with the HIV and MyCt diagnoses in `ep2`. This happens because by default, `episode` tracking occurs in one direction of time (`from_last`). You can correct for this by simultaneously tracking `events` in both directions i.e. before and after an index `event`. This is either done by changing `bi_direction` to `TRUE` or by using an applicable cut-off range i.e. `r format(number_line(-6,6))`. See the examples below. 

```{r warning=FALSE}
# Track preceeding and concurrent infections up to 6 months BEFORE OR AFTER the HIV diagnosis

# Method 1a
# Track diagnoses 6 months AFTER the HIV diagnosis.
  # `bi_direction` then tells the function to also check 6 months BEFORE the HIV diagnosis
ds2$ep3a <- fixed_episodes(date = ds2$date, custom_sort = ds2$user_ord, case_length = 6, 
                           bi_direction = T, episode_unit = "months", display = F)

# Method 1b
# Track diagnoses 6 months BEFORE the HIV diagnosis
  # bi_direction` then tells the function to also check 6 months AFTER the HIV diagnosis
ds2$ep3b <- fixed_episodes(date = ds2$date, custom_sort = ds2$user_ord, case_length = -6,
                           bi_direction = T, episode_unit = "months", display = F, 
                           data_source = ds2$diag)

ds2$ep3_ds <- ds2$ep3b@epid_dataset

# Method 2a
# Track diagnoses 6 months BEFORE or AFTER the HIV diag with an applicable. 
  # There's no need for `bi_direction`.
rng <- number_line(-6, 6)
ds2$ep4 <- fixed_episodes(date = ds2$date, custom_sort = ds2$user_ord, case_length = rng, episode_unit = "months",
                          display = F, data_source = ds2$diag)

ds2$ep4_ds <- ds2$ep4@epid_dataset

# Method 2b
# Track diagnoses between 2 and 6 months AFTER the HIV diagnosis. 
  #` bi_direction` then tells the function to also check between 2 and 6 months BEFORE the HIV diagnosis
# Diagnoses before 2 months on either side are skipped as mentioned in the "cut-offs" section
rng2 <- number_line(2, 6)
ds2$ep5 <- fixed_episodes(date = ds2$date, custom_sort = ds2$user_ord, case_length = rng2, 
                          bi_direction =T, episode_unit = "months", display = F)

ds2
```

When different `events` have the same level of preference - `custom_sort` values, their chronological order are used to break ties. This will be the earliest or most recent `event` depending on `from_last`. Alternatively, you can break such ties with additional levels of `custom_sort`.

Using `infections` - a sample dataset for positive urinary tract infections (UTI), bloodstream infections (BSI) and respiratory tract infections (RTI), we can see examples of `episode tracking` using 2 and 3 levels of `custom_sort`.

```{r warning=FALSE, message=FALSE}
dbf <- infections[c("date", "infection")]

# 3 levels: "UTI" > "BSI" > "RTI"
dbf$c_sort1 <- ifelse(dbf$infection == "UTI", 1, ifelse(dbf$infection == "BSI", 2, 3))
# 2 levels: "UTI" > ("BSI" OR "RTI")
dbf$c_sort2 <- ifelse(dbf$infection == "UTI", 1, 2)
# 2 levels: "BSI" > ("UTI" OR "RTI")
dbf$c_sort3 <- ifelse(dbf$infection == "BSI", 1, 2)

dbf$ep_1 <- fixed_episodes(dbf$date, case_length = 15, data_source = dbf$infection, 
                           custom_sort = dbf$c_sort1, display = F)

dbf$ep_2 <- fixed_episodes(dbf$date, case_length = 15, data_source = dbf$infection, 
                           custom_sort = dbf$c_sort2, display = F)

dbf$ep_3 <- fixed_episodes(dbf$date, case_length = 15, data_source = dbf$infection, 
                           custom_sort = dbf$c_sort3, display = F)

dbf
```

<a id ="recurrence" ><a/> 

### Recurrent events and periods of recurrence
Another important consideration for a case definition should be if the `events` recurs. For example, if a relapse of the same disease occurs after a  successful treatment therapy, it may be more relevant to treat this as the same `episode` of the initial `event`.

*fixed_episodes() will treat these as a separate `episodes` while `rolling_episodes()` can treat them as the same `episode`.* 

All arguments in `fixed_episodes()` (including  `case_length`) function the same way as in `rolling_episodes()`. However, the `recurrence_length` argument, which is unique to `rolling_episodes(),` provides the cut-off period for `recurrent events`. For example, a `recurrence_length` of `10` means that; repeat `events` within `11` days of the last `duplicate event` (of the initial index `event`) are considered a recurrence of the index `event`.

*If `recurrence_length` is not supplied, it's assumed to be the same as the `case_length`.*

**Figure 3a: rolling episodes**
```{r warning=FALSE}
# 6-day (5-day difference) episodes with 11-days recurrence periods - rolling episodes
ds$r1 <- rolling_episodes(ds$date, case_length = 5, recurrence_length = 10, display = F)

ds$r1
```

```{r echo=FALSE, fig.height=4, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = ds$r1, date= ds$date, case_length = 5, recurrence_length = 10)
```

Similarly, for `recurrence_length`, your cut-off can be a range. For example, a `recurrence_length` of ``r format(number_line(13, 15))`` means that; repeat `events` within `14` and `16` days after the last `duplicate event` are considered a recurrence of the `reference event`. 

**Figure 3b: rolling episodes with a cut-off range**
```{r warning=FALSE}
rng <- number_line(13, 15); rng
ds$r2 <- rolling_episodes(ds$date, case_length = 5, recurrence_length = rng, display = F)

ds$r2
```

```{r echo=FALSE, fig.height=4, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = ds$r2, date= ds$date, case_length = 5, recurrence_length = rng)
```

`Events` before the `14th` are skipped by default however, you can also change `skip_if_b4_lengths` to `FALSE`, so that such `events` are not skipped. 

**Figure 3c: rolling episodes where events before the the cut-off range are not skipped**
```{r warning=FALSE}
rng <- number_line(13, 15); rng
ds$r3 <- rolling_episodes(ds$date, case_length = 5, recurrence_length = rng, 
                          skip_if_b4_lengths = F, display = F)

ds$r3
```

```{r echo=FALSE, fig.height=4, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = ds$r3, date= ds$date, case_length = 5, recurrence_length = rng)
```

#### Index events for periods of recurrence

Unlike `"fixed episodes"`, each `"rolling episode"` has at least two index `events` - one for the whole `episode` and one for each recurrence period. By default, the last `event` of the previous `window` is the index `event` for the next recurrence period. However, you can change `recurrence_from_last` to `FALSE`, so that the first `event` in the previous window is used instead. See a demonstration of this below.

*If your `case_length` and `recurrence_length` are the same, which is the default behaviour, you'll have essentially created a `"fixed episode"`*. 

```{r message=FALSE, warning=FALSE}
df <- c("01/04/2019", "11/04/2019", "16/04/2019","21/04/2019", "07/05/2019")
df <- data.frame(date= as.Date(df, "%d/%m/%Y"))

# 15-day fixed episodes
df$f1 <- fixed_episodes(df$date, case_length = 14, display = F)

# 15-day rolling episodes with 15-day recurrence periods
  # Since the first event is the reference event for the next recurrence window and,
  # the recurrence_length is the same the case_length (14-day difference), 
  # the result will be the same as the 15-day fixed-episode (above) 
df$r1 <- rolling_episodes(df$date, case_length = 14, recurrence_from_last = F, 
                          to_s4 = T, display = F)

df

# Identical
all(df$f1==df$r1)
```

**Figure 4a: Last event in a window taken as the reference event for the next recurrence window (default)**
```{r message=FALSE, warning=FALSE}
df$r2 <- rolling_episodes(df$date, case_length = 14, recurrence_length = 16, display = F)

df$r2
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = df$r2, date = df$date, case_length =14, recurrence_length = 16)
```

**Figure 4b: First event in a window taken as the reference event for the next recurrence window**
```{r message=FALSE, warning=FALSE}
df$r3 <- rolling_episodes(df$date, case_length = 14, recurrence_length = 16, 
                          recurrence_from_last = F, display = F)

df$r3
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = df$r3, date = df$date, case_length =14, recurrence_length = 16)
```

#### Case windows for both case and recurrent events
You can use the `case_for_recurrence` argument to specify that both `case` and `recurrence events` should have a `case window`. The default behaviour is that only `case events` have a `case window`. See a demonstration of this below. 

*The `wind_id` slot shows the `window` for every `event`, while `wind_nm` slot shows type of `window` it is.*

*Example 1*

```{r message=FALSE, warning=FALSE}
df <- c("01/04/2019", "11/04/2019", "16/04/2019","21/04/2019","25/04/2019", "07/05/2019")
df <- data.frame(date= as.Date(df, "%d/%m/%Y"))
```

**Figure 5a: Case windows for case events only (default)**
```{r message=FALSE, warning=FALSE}
df$r4 <- rolling_episodes(df$date, case_length = 10, display = F)

df$r4
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = df$r4, date = df$date, case_length =10, recurrence_length = 10)
```

**Figure 5b: Case windows for case and recurrence events**
```{r message=FALSE, warning=FALSE}
df$r5 <- rolling_episodes(df$date, case_length = 10, case_for_recurrence = T, 
                          to_s4 = T, display = F)

df$r5
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = df$r5, date = df$date, case_length =10, recurrence_length = 10)
```

*Example 2.*

```{r message=FALSE, warning=FALSE}
date <-  seq.Date(as.Date("01/04/2019", "%d/%m/%Y"), 
                  as.Date("21/04/2019","%d/%m/%Y"), 
                  by="3 day")
# Example 2
df2 <- data.frame(date = date, sn = 1:length(date))
# dates
df2$date
```

**Figure 5c: Case windows for case events only (default)**
```{r message=FALSE, warning=FALSE}
df2$r1 <- rolling_episodes(df2$date, case_length = 6, recurrence_length = 4, display = F, sn=df2$sn)

df2$r1
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = df2$r1, date = df2$date, case_length =6, recurrence_length = 4)
```

**Figure 5d: Case windows for case and recurrence events**
```{r message=FALSE, warning=FALSE}
df2$r2 <- rolling_episodes(df2$date, case_length = 6, recurrence_length = 4, 
                           case_for_recurrence = T, display = F, sn=df2$sn)

df2$r1
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = df2$r2, date = df2$date, case_length =6, recurrence_length = 4)
```

Notice that in the 4 examples, all `events` have been assigned to the same `episode` but the number of `recurrent events` differ.

### Number of recurrence periods and episodes
Some case definitions may only require you to track the first `n`-number of `episodes`, or those that only recurred `n`-number of times. You can incorporate these requirements into your analysis using `episodes_max` and `rolls_max` (only applicable to `rolling_episodes()`). When each `strata` (see [stratified grouping](#stratified_grouping)) of the dataset has the maximum number of `episodes` (`episodes_max`), subsequent `events` are skipped and assigned unique episode IDs. The default option for `episodes_max` is `Inf` i.e. continue until every `event` has been grouped into `episodes`. See the examples below.

```{r warning=FALSE, message=FALSE}
data("infections_3");
dbs <- infections_3[c("pid","date")]; 
# dates
dbs$date
```

**Figure 6a: Maximum of one fixed episode per strata**
```{r message=FALSE, warning=FALSE}
dbs$eps_1 <- fixed_episodes(strata = dbs$pid, date = dbs$date, case_length = 3, display = F, 
                            episodes_max = 1)

dbs$eps_1
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = dbs$eps_1, date = dbs$date, case_length =3)
```

**Figure 6b: Maximum of two fixed episodes per strata**
```{r message=FALSE, warning=FALSE}
dbs$eps_2 <- fixed_episodes(strata = dbs$pid, date = dbs$date, case_length = 3, display = FALSE, episodes_max = 2)

dbs$eps_2
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = dbs$eps_2, date = dbs$date, case_length =3)
```

`rolls_max` is the maximum number of times an `event` can recur. When `rolls_max` is reached, the `episode` ends. A new one then begins if the number of `episodes` in that `strata` is less than `episode_max`. The default option for `rolls_max` is `Inf` i.e. check until there are no more `events` within the `recurrence period` of the `reference event`. See the examples below.

**Figure 6c: Infinite recurrence periods per episode per strata (default)**
```{r message=FALSE, warning=FALSE}
dbs$eps_4 <- rolling_episodes(strata = dbs$pid, date =dbs$date, case_length = 2,display = F)

dbs$eps_4
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = dbs$eps_4, date = dbs$date, case_length =2, recurrence_length = 2)
```

**Figure 6d: Maximum of one recurrence period per episode per strata**
```{r message=FALSE, warning=FALSE}
dbs$eps_6 <- rolling_episodes(strata = dbs$pid, date =dbs$date, case_length = 2,display = F, 
                              rolls_max = 1)

dbs$eps_6
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = dbs$eps_6, date = dbs$date, case_length =2, recurrence_length = 2)
```

Note that if `case_for_recurrence` is `TRUE`, after checking for `recurrence` in the last `recurrence period`, the function will also check for `duplicates` within the `case window` of the last `recurrent event`. See below.

**Figure 6e: Maximum of one recurrence period per episode per strata when case_for_recurrence is TRUE**
```{r message=FALSE, warning=FALSE}
dbs$eps_7 <- rolling_episodes(strata = dbs$pid, date =dbs$date, case_length = 2,display = F, 
                              rolls_max = 1, case_for_recurrence = T)

dbs$eps_7
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = dbs$eps_7, date = dbs$date, case_length =2, recurrence_length = 2)
```

<a id="interval_grouping"></a>

### Interval grouping
Some case definitions can involve `events` that occur over a period of time and not a single point in time e.g hospital admissions. `fixed_episodes()` and `rolling_episodes()` can be used to track such `event periods` into `episodes`. This type of `episode` grouping is recommended when the end point of an `event` is known. For example, it's near impossible to know the exact point in time an individual diagnosed with the common cold recovers however, it's a reasonable assumption that a second diagnosis 3 months after is not the same one that was diagnosed initially. For situations like this, the recommend approach is to use the methods we've covered so far. In contrast, hospital admissions typically have recorded admission and discharge times or dates and so interval grouping is recommended. This being said, in several situations both approaches can be used interchangeably. See below. 

```{r message=FALSE, warning=FALSE}
# Dates
dates <- seq(as.Date("01/04/2019", "%d/%M/%Y"), as.Date("20/04/2019", "%d/%M/%Y"), "4 days")
case_len <- 4

# Periods 
periods <- number_line(dates, dates + 4)

dates
periods

# Track fixed episodes from events with a 5 day cut-off 
mth1 <- fixed_episodes(date = dates, case_length = 4, display = F)

# Track fixed episode from periods that are 5 days long 
mth2 <- fixed_episodes(date = periods, case_length =0, display = F)

# Same results
mth1; mth2

# Track rolling episodes from events using a 5 day cut-off 
mth3 <- rolling_episodes(date = dates, case_length = 4, display = F)

# Track rolling episode from periods that are 5 days long 
mth4 <- rolling_episodes(date = periods, case_length =0, display = F)

# Same results
mth3; mth4
```

In interval grouping, when `case_length` is `0`, `event periods` that overlap with the index `event period` are grouped together as one `episode`. However, if `case_length` is `> 0`, only those within `n`-days (or any time unit) after the `end_point()` of the index `event period` are grouped together. See below. 

```{r message=FALSE, warning=FALSE}
hos_admin <- diyar::hospital_admissions
hos_admin$admin_period <- number_line(hos_admin$admin_dt, hos_admin$discharge_dt)

# Hospital stay
hos_admin$admin_period
```

**Figure 7a: Tracking periods of hospital stay (admission -> discharge)**
```{r message=FALSE, warning=FALSE}
hs_epids_a <- fixed_episodes(date=hos_admin$admin_period, case_length = 0, 
                display=F, group_stats=T)
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = hs_epids_a, date = hos_admin$admin_period, case_length = 0)
```

**Figure 7b: Tracking periods of hospital stay up to 20 days after the first discharge**
```{r message=FALSE, warning=FALSE}
hs_epids_b <- fixed_episodes(date=hos_admin$admin_period, case_length = 20, 
                display=F, group_stats=T)
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = hs_epids_b, date = hos_admin$admin_period, case_length = 20)
```

**Figure 7c: Tracking periods of continuous hospital stay i.e. re-admission within 15 days**
```{r message=FALSE, warning=FALSE}
hs_epids_c <- rolling_episodes(date=hos_admin$admin_period, case_length = 0, 
                recurrence_length=15, display=F, group_stats=T)
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = hs_epids_c, date = hos_admin$admin_period, case_length = 0, recurrence_length=15)
```

There are 6 ways `event periods` can overlap (`overlap_methods`). These are `"exact"`, `"across"`, `"inbetween"`, `"chain"`, `"aligns_start"` and `"aligns_end"`. These are covered in more detail in an accompanying [vignette](number_line.html#overlaps). Only `event periods` that overlap by a specified `overlap_method` will be grouped into the same `episode`. You can use any combination of the 6 methods but the default option is to use all 6. See below for a demonstration of this.

*The 6 `overlap_methods` are mutually exclusive.*

*There are 2 convenience methods - `"none"` and `"overlap"`. These are mutually inclusive with any the other 6.*

```{r warning=FALSE}
# wrapper function to use with lapply
epi_grp_func <- function(x){
  epids <- fixed_episodes(date=hos_admin$admin_period, 
                 sn=hos_admin$rd_id, 
                 case_length = 0, 
                 overlap_methods = x, 
                 display = FALSE, 
                 to_s4 = TRUE, 
                 group_stats = TRUE)
  
  # for the prurpose of this demonstration, limit to overlapped periods    
  epids[epids@epid_total>1]
}

# Methods 
methods <- list(
  # Identical intervals
  exact = "exact",
  # Overlapping intervals
  across= "across",
  # Intervals with aligned start points
  aligns_start = "aligns_start",
  # Intervals with aligned end points
  aligns_end = "aligns_end",
  # Chained intervals
  chain = "chain",
  # Intervals occurring completely within others
  inbetween = "inbetween",
  # Chained intervals and those occurring completely within others
  cb1 = "chain|inbetween",
  # Chained intervals, identical intervals and those occurring completely within others
  cb2 = "exact|chain|inbetween",
  # Chained intervals, overlapping intervals and those with aligned end point
  cb3 = "across|chain|aligns_end"
)

epids <- lapply(methods, epi_grp_func)
names(epids) <- names(methods)

# Results
epids["chain"]

epids["cb2"]
```

*Only showing `events` grouped into `episodes`*

**Figure 8a: Grouped episodes when considering only "exact" overlap method**
```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
eps <- epids[["exact"]]
plot_epid(epid = eps, date = hos_admin$admin_period[eps@sn] , case_length = 0)
```

**Figure 8b: Grouped episodes when considering only "chain" overlap method**
```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
eps <- epids[["chain"]]
plot_epid(epid = eps, date = hos_admin$admin_period[eps@sn] , case_length = 0)
```

**Figure 8c: Grouped episodes when considering "chain" or "inbetween" overlap method**
```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
eps <- epids[["cb1"]]
plot_epid(epid = eps, date = hos_admin$admin_period[eps@sn] , case_length = 0)
```

#### Case and recurrence lengths in interval grouping

```{r warning=FALSE}
pa <- c("28/03/2019", "01/04/2019", "03/04/2019", "07/04/2019","12/04/2019")
pz <- c("31/03/2019", "10/04/2019", "05/04/2019", "09/04/2019","13/04/2019")

pa <- as.Date(pa, "%d/%m/%Y")
pz <- as.Date(pz, "%d/%m/%Y")

periods <- number_line(pa, pz)
periods

```

As seen earlier,  positive "length" means that; `event periods` overlapping with the index `event period` and those within `n`-days AFTER the `end_point()` of the index `event period` will be grouped into the same `episode`. See another example below.

**Figure 9a: Fixed episodes with a case_length of 6**
```{r message=FALSE, warning=FALSE}
eps_a <- fixed_episodes(periods, case_length =6, group_stats = T, display = F)

eps_a
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = eps_a, date = periods, case_length = 6)
```

In contrast, a negative "length" means that; only `event periods` within `n`-days BEFORE the   `end_point()` of the index `event period` will be grouped into the same `episode`.

**Figure 9b: Fixed episodes with a case_length of -2**
```{r message=FALSE, warning=FALSE}
eps_b <- fixed_episodes(periods, case_length =-2, group_stats = T, display = F)

eps_b
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = eps_b, date = periods, case_length = -2)
```

By default, overlapping periods that are outside the 2-day periods are also groupped together. This can be changed with `include_initial_period`. See below.

**Figure 9c: Fixed episodes with a case_length of -2**
```{r message=FALSE, warning=FALSE}
eps_c <- fixed_episodes(periods, case_length =-2, group_stats = T, display = F,
                        include_index_period = F)

eps_c
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = eps_c, date = periods, case_length = -2)
```

**Figure 9d: Fixed episodes with a case_length of -6**
```{r message=FALSE, warning=FALSE}
eps_d <- fixed_episodes(periods, case_length =-6, group_stats = T, display = F)

eps_d
```

```{r echo=FALSE, fig.height=5, fig.width=8.5, message=FALSE, warning=FALSE}
plot_epid(epid = eps_d, date = periods, case_length = -6)
```

<a id= "stratified_grouping"></a>

### Stratified episode grouping
In practice, you'll want to track `episodes` separately for groups (`strata`) such as patients, pathogens, sources of infection or any combination of these. This means that `episodes` from one patient will be different from other patients, or `episodes` of HIV diagnoses will be different those of HBV diagnoses. 

*`episodes` from different `strata` can have a different `case_lengths` and/or `recurrence_lengths`.*

*`record_group()` is useful for creating group identifiers which can then be used as a `strata`. See the [record group vignette](record_group.html) for further details.*

As an example, using the `infections` dataset, a case definition may specify the following;

- UTI and BSI diagnoses are considered different `episodes` regardless of when they occur
- UTI `episodes` have a cut-off of 8 days and a recurrence period of 31 days
- BSI `episodes` have a cut-off of 15 days and no recurrence period

By adding the `infection` column to the `strata` argument, `"UTI"` and `"BSI"` diagnoses will not be grouped together under the same `episode`. Furthermore, the `case_length` and `recurrence_length` for each will be different as specified in the `epi` and `recur` columns respectively.

```{r warning=FALSE}
dbs <- diyar::infections[c("date","infection")]
dbs <- dbs[dbs$infection%in% c("UTI","BSI"),]
dbs$epi <- ifelse(dbs$infection=="UTI", 7, 14)
dbs$recur <- ifelse(dbs$infection=="UTI", 30, 0)

dbs$epids <- rolling_episodes(date=dbs$date, case_length =dbs$epi, to_s4 =TRUE, 
                              strata = dbs$infection, recurrence_length = dbs$recur, 
                              display = FALSE, group_stats = TRUE)

dbs
```

Stratified grouping is a faster and easier alternative to performing separate analyses for each subset (`strata`) of the dataset. However, if you must perform these separately, I recommend using a familiar `sn` and changing `to_s4` to `FALSE`. The former is so that you can easily link each `episode` back to the original dataset, while the latter is because binding `S4` objects in my personal opinion is a pain, so `to_s4 = FALSE` changes the `epid` objects to `data.frames`.

*to_s4() and to_df() are convenience functions to change `epid`, `pid`, `number_line` S4 class objects to `data.frames` and vice versa.*

<a id="sub_strata"></a>

#### Sub-strata
`Sub-strata` are when `events` within the same `strata` have different cut-offs. The case definition below demonstrates how this could be beneficial.

- UTI and BSI diagnoses are considered different `episodes` regardless of when they occur 
- UTI diagnoses have a cut-off of 8 days and a recurrence period of 31 days
- BSI diagnoses have a cut-off of 15 days if not treated but 5 days if `treated`. In both situations there is no recurrence period.
- RTI diagnoses have a cut-off of of 29 days and a recurrence period of 6 days

In this example, whether or not the infection is `treated` should be viewed as the `sub-strata` i.e. in a patient (`strata`), an `episode` is expected to last longer if it's not `treated`. 

```{r warning=FALSE}
dbs <- diyar::infections_4

dbs$epids <- episode_group(dbs, sn=rid, strata=c(pid, organism, source), date=date, 
                case_length =epi, episode_type = "rolling", recurrence_length = recur,
                display = FALSE)

dbs
```

There are a few things to note with stratified grouping;

- Unless required, `case_length` and `recurrence_length` should be consistent for each `strata` otherwise, you'll inadvertently create a sub-strata
- `Episode grouping` with and without a sub-strata are different and could lead to different results
- Using a `sub-strata` is not the same as adding that `sub-strata` to the `strata` argument. In the example above, adding `treated` to `strata` will group `treated` infections separately from untreated infections. While this could be the desired outcome depending on your case definition, the case definition above did not require this, only that the `treated` infections last longer.

## Cut down your processing time

Some case definitions are so specific that only certain kinds of `episodes` will be required. In such cases, you can save time by skipping `events` from `episodes` that aren't required. There are 3 mechanisms to skip such `events`. 

*Skipped `events` are assigned unique episode IDs and their `case_nm` slot is flagged as `"Skipped"`.*

### Skip subsets of the dataset 
You can skip an entire `strata` of the dataset by changing it to `NA`. In the example below, assuming you were not interest in tracking `"GP1"` and `"GP2"` records, you can skip these to save time.

*Changing `display` to `TRUE` shows how many iterations of the grouping process it's taken to complete the entire process.*

```{r warning=FALSE, message=FALSE}
dbs <- head(hourly_data[c("datetime","category")], 10)
dbs$subset <- ifelse(dbs$category!="GP3", NA, "group")

# To skip OR
dbs$epids_a <- rolling_episodes(strata= dbs$subset, date = dbs$datetime, case_length = 5, 
                                episode_unit = "hours", recurrence_length = 9, display = TRUE)

#   OR

# Not to skip
dbs$epids_b <- rolling_episodes(strata= dbs$category, date = dbs$datetime, case_length = 5, 
                                episode_unit = "hours", recurrence_length = 9, display = TRUE)

dbs
```

### Skip the nth order (skip order) of custom sort
In a dataset with multiple levels of `custom_sort`, you can skip `episodes` that will begin with the `nth` level (`skip_order`). A `skip_order` of `1` means that; after every `event` with the first level of your `custom_sort` has been grouped into `episodes`, the tracking process will come to an end.

This is handy when you're grouping `episodes` from rare and common `events`, the rare `events` are the index `events` and it's a hassle to subset the dataset.

```{r warning=FALSE, message=FALSE}
dbf <- dbf[c("date", "infection")]
dbf$c_sort <- ifelse(dbf$infection == "UTI", 1, ifelse(dbf$infection == "BSI", 2, 3))

# Skip episodes that would begin with BSI/UTI records
dbf$ep_a <- fixed_episodes(dbf$date, case_length = 15, data_source = dbf$infection, 
                           custom_sort = dbf$c_sort, skip_order = 1)
dbf$ep_a_d <- dbf$ep_a@epid_dataset

# Don't skip any episodes
dbf$ep_b <- fixed_episodes(dbf$date, case_length = 15, data_source = dbf$infection, 
                           custom_sort = dbf$c_sort)
dbf$ep_b_d <- dbf$ep_b@epid_dataset

dbf
```

Notice that in the skipped example `ep_a`, there are no `episodes` that has a `"BSI"` or `"RTI"` record as the `"case"`.

### Skip episodes without records from certain data sources
The third mechanism is partly a misnomer because it does not skip `events` but rather ungroups `episodes` after they've already been created. After `episodes` have been created, those that do not contain records from certain `data_sources` can be ungrouped using `data_links`. In such instances, the overall execution time will not be shortened but you'll get an `episode` identifier that's relevant to the `data_sources` you're interested in. However, if a `strata` will not produce `episodes` with the required combination of `data_sources`, that entire `strata` will be skipped. If this happens, the overall execution may be shortened.

```{r warning=FALSE, message=FALSE}
dttm <- function(x) as.POSIXct(x, "UTC",format="%d/%m/%Y %H:%M:%S")
dbg <- data.frame(date = seq.POSIXt(dttm("01/04/2018 00:00:00"), dttm("31/05/2018 00:00:00"),
                                    by="3 days"))
dbg <- head(dbg, 11)
dbg$recurrence <- 2
dbg$case_len <- 6
dbg$dataset <- paste("DS",c(1:3, rep(c(1:2),2), rep(3,4)), sep="")

# Don't skip any
dbg$ep_a <- episode_group(dbg, date = date, case_length = case_len, episode_type ="rolling", 
                          recurrence_length = recurrence, data_source = dataset, to_s4 = T,
                          display = F)

# Breakup episodes without events from the `DS3` `data_source` 
  # The `DS3` event MUST BE linked to events from other `data_sources`  
dbg$ep_b <- episode_group(dbg, date = date, case_length = case_len, episode_type ="rolling", 
                          recurrence_length = recurrence, data_source = dataset, to_s4 = T,
                          data_links = "DS3", display = F)

# Breakup episodes without events from the `DS3` `data_source` 
  # The `DS3` event DOESN'T HAVE to be linked to events from other `data_sources`   
dbg$ep_c <- episode_group(dbg, date = date, case_length = case_len, episode_type ="rolling", 
                          recurrence_length = recurrence, data_source = dataset, to_s4 = T,
                          data_links = list(g="DS3"), display = F)

# Breakup episodes without events from the `DS3` `data_source` 
  # The `DS3` event MUST BE linkned to events from the `DS1` `data_source`
dbg$ep_d <- episode_group(dbg, date = date, case_length = case_len, episode_type ="rolling", 
                          recurrence_length = recurrence, data_source = dataset, to_s4 = T,
                          data_links = list(l=c("DS3","DS1")), display = F)

dbg[c("date", "dataset", "ep_a", "ep_b", "ep_c", "ep_d")]
```

<a id="tips"></a>

## Useful ways of using these functions

### Episode grouping in other units of time
`episode grouping` can be done in other units of time (`episode_unit`). Acceptable options are `"seconds"`, `"minutes"`, `"hours"`, `"days"`, `"weeks"`, `"months"` or `"years"`. Below is an example of `episode grouping` by the hour.

```{r warning=FALSE, message=FALSE}
dbs <- diyar::hourly_data

# Each unit is relative to a set number of seconds. 
diyar::episode_unit

# 1-day fixed episodes
fixed_episodes(date = dbs$datetime, case_length = 1, episode_unit = "days", 
               group_stats = TRUE, display = FALSE)

# 5-hr fixed episodes
fixed_episodes(date = dbs$datetime, case_length = 5, episode_unit = "hours", 
               group_stats = TRUE, display = FALSE)

# 5-hr rolling episodes
rolling_episodes(date = dbs$datetime, case_length = 5, episode_unit = "hours", 
                 group_stats = TRUE, display = FALSE)
```

### Use a `strata` from `record_group()`
You can used `pid` objects from `record_group()` as a `strata`.

```{r warning=FALSE, message=FALSE}
dbs <- diyar::infections[c("date","infection")]; dbs

# familiar unique record ids for reference - optional
dbs$rd_id <- c(640,17,58,21,130,79,45,300,40,13,31)

# strata based on matching sources of infection
dbs$pids <- record_group(dbs, sn = rd_id,  criteria = infection, display = FALSE)

# stratified grouping 
dbs$epids <- fixed_episodes(sn = dbs$rd_id, date = dbs$date, strata = dbs$pids, 
                             to_s4 = TRUE, display = FALSE, case_length = 10)

dbs
```

### Use numeric values for the date argument 
`date` and `datetime` objects are fundamentally numeric values within the context of a reference point (`as.Date(..., origin)`). The `episode grouping` process ignores this context and instead uses each value as a reference point for others. Therefore, you use `numeric` values instead of `date` or `datetime` values for the `date` argument. For example, if you use `0-2`, it does not matter what they represent i.e. number of days from a particular date or number of seconds from a particular time. It only matters that `0` is before `1`, which in turn is before `2`. When the functions are used this way, the `episode_unit` argument is ignored.

```{r warning=FALSE, message=FALSE}
vals <- c(8.1,6,12,8.5,12,3,8,15,5,7)

vals

fixed_episodes(vals, case_length = .5, group_stats = T, display = F)

fixed_episodes(vals, case_length = 5, group_stats = T, display = F)

fixed_episodes(vals, case_length = 100, group_stats = T, display = F)
```

# Conclusion
There are a variety of ways to use these function. Before beginning, It's worth reviewing your case definition and its implication on the dataset. In general, the following steps can serve as a quick guide on how to use them;

1. Work out the `strata` in your dataset
2. Choose and specify whether you need `"fixed"` or `"rolling"` episodes
3. Choose and specify whether you are grouping individual events or periods of events by supplying a `date`, `datetime` or `number_line` object as required. See [interval grouping](#interval_grouping)
4. Choose and specify the required `case_length`, and/or `recurrence_length`. The values should be unique to each `strata` unless you require a [sub-strata](#sub_strata)
5. Change `from_last` to `TRUE` if you want the index `event` to be the earliest or most recent `event`.
6. If you need the index `event` to be the earliest or most recent event of a particular type of event, use `custom_sort` in combination with `from_last`. If not, ignore this argument. See [user defined case assignment](#custom_sort)
7. If you require `episodes` to include `events` on either side of the index `event`, use `bi_direction` or an applicable `case_length` or `recurrence_length`. If not, ignore this point
8. Determine if you are measuring `episodes` by the minute, hour or day e.t.c., and set `episode_unit` accordingly. Be sure to supply a `datetime` to the `date` argument if `episode_unit` is less than `"days"`.

These functions should prove useful in epidemiological analyses however, it's also applicable to analyses in any field where the aim is to track events into temporal groups.

