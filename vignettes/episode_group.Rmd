---
title: "Getting started with episode_group"
#author: "Olisa Nsonwu"
#date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting started with episode_group}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Overview
There are a varierty of ways to use this function. It's worth reviewing your case definition and its implication on the dataset before using this function. In general the following steps will guide you in using this function;

1. work out which columns should be the `strata`
2. choose whether you need `"fixed"` or `"rolling"` episodes
3. choose whether you are grouping individual events or a duration of events by supply a date, datetime or `lubridate interval` object as required. See [interval grouping](#interval_grouping)
4. create a colum for `case_length`, and/or `recurrence_length`. The values should be unique to each `strata` unless you require a [sub-strata](#sub_strata)
5. change `from_last` to `TRUE`if you want to start episode grouping at the most recent record thereby making it the `"Case"`. Note that this is not the same as starting episode grouping at the earliest record (`from_last` is `FALSE`) and then picking the most recent record in that episode as the `"Case"`. See [case assignment](#case_assignment)
6. if you require the `"Case"` to be the earliest or most recent record from a particular type of record use `custom_sort` in combination with `from_last`. If not, ignore this argument. See [user defined case assignment](#custom_sort)
7. if you require episodes to include records on either side of the `"Case"` use `bi_direction`. If not, ignore this argument
8. determine if episodes are occuring by the minute, hour or day etc. #Set `episode_unit` accordingly

#Introduction
Deduplicating records is a main part of case definitions in epidemiological analysis. In these analysis, a reference event is selected and considered the start of an episode, while subequent events within a specified period are considered duplicates.

`episode_group()` aims to provide a simple and flexible way to group records from multiple datasets into episodes, each lasting a specified period of time. 

#Uses
The arguments in `episode_group()` can be used to deduplicate records in different ways. The flexible application of both [`record_group`](record_group.html) and `episode_group()` can allow you apply a variety of case definitions to a dataset. Below are some examples;

1. Group events (dated records) or intervals (records with start and end periods) into episodes lasting a fixed period (`case_length`) from a reference event or interval (`"Case"`). See [episode grouping](#episode_grouping)
2. Create episodes that continue to reoccur within a fixed period (`recurrence_length`) of the last event or interval
3. Create episodes as in examples 1 and 2, and specify which event is considered the `"Case"`. See [case assignment](#case_assignment)
4. Create episodes with different a different `case_length` and/or `recurrence_length` for different subsets of a dataset. See [stratified grouping](#stratified_grouping)
5. Create episodes of overlaping events (time points) e.g. days, minutes, hours. See [Useful ways of using episode_group](#tips)
6. Create episodes overlaping intervals (time periods) e.g. periods of days, minutes or hours. See [interval grouping](#interval_grouping)

#Implementation 

<a id= "episode_grouping"></a>

##Episode grouping
An episode as produced by `episode_group()` is a set of events/intervals within a specific time period. Each episode begins with a reference event/interval (`"Case"`), and each subsequent event/interval within the episode is flagged as a `"Duplicate"` of the `"Case"`.

`episode_group()` can produce two type of episodes described below; 

- `"fixed"` episodes - all events/intervals are within the `case_length` of the `"Case"`. Any events/intervals after the `case_length` of the initial `"Case"` is considered a new epsiode. See [stratified grouping](#stratified_grouping)

- `"rolling"` episodes - all events/intervals within the `case_length` of the `"Case"`, and those within periods of recurrence are grouped into episodes. See [episodes windows and recurrence periods](#recurrence).

Note that a `"fixed"` episode will only have duplicates of the `"Case"` but a `"rolling"` episode may have duplicates of both the `"Case"` and `"Recurrent"` events/intervals.

<a id ="recurrence" ><a/> 

##Episode windows and recurrence periods
An episode window (`epid_interval`) is the period between the `"Case"` and the episode's last event, or the end period of the last interval. For `"fixed"` episodes, the maximum episode length (`epid_length`) is equal to the `"case_length"`.

A recurrence period is the period between the last event/interval in an episode and a specified `recurrence_length` afterwards. Only `"rolling"` episodes can have a recurrence period. There can also be multiple recurrence periods within one episode. For a `"rolling"` episode, the episode window (`epid_interval`) is the period covering the initial `case_length` and all recurrence periods of the episode.

The two examples below demonstrates the different implementations of `"fixed"` and `"rolling"` episode grouping.

#### Example of `"fixed"` episode grouping
```{r warning=FALSE, message=FALSE}
library(dplyr)
library(lubridate)
library(diyar)

infections <- data.frame(
  rid = 1:6,
  date = c(seq.Date(dmy("01/04/2019"), dmy("25/04/2019"), "5 day"), dmy("04/06/2019")),
  pid = 1, infx = rep("E. coli BSI",6), epi = 14, recur = 7, stringsAsFactors = FALSE
)

# Fixed episode
fixed_episodes <- cbind(
  infections,
  episode_group(infections, rid, pid, date, epi, 
                group_stats = TRUE)
  )

fixed_episodes

```

Records 1 to 3 are assigned a unique episode ID (`"1"`) (Table 1). In this instance, record 1 is considered the initial `"Case"` and records 2 and 3 its duplicates. This is because records 2 and 3 are dated within 15 days of record 1 (difference of 14 days). Record 4 is dated after this 15-day period and hence begins a new `"Case"` which is assigned episode ID `"4"`. Record 5 is within 15 days of record 4 (`"Case"`), so it's considered a `"Duplicate"` of record 4 and assigned the same episode ID as record 4. This process continues chronologically until all records have been assigned an episode ID.

#### Example of `"rolling"` episode grouping
```{r warning=FALSE, message=FALSE}
# Rolling episode
# Progress messages can be turned off using the display argument
rolling_episodes <- cbind(
  infections,
  episode_group(infections, sn = rid, strata = pid, date =date, 
                case_length = epi, episode_type = "rolling",
                recurrence_length = recur, 
                display = FALSE, group_stats = TRUE)
  )

rolling_episodes

```

In the `"rolling"` episode example, records 1 to 3 are also considered the same episode and therefore assigned the same episode ID (Table 1). However, unlike the `"fixed"` episode example, record 4 is not considered a new `"Case"`, instead it's considered a `"Recurrent"` record because it's within 8 days of the last `"Duplicate"` (record 3). Similarly, record 5 is within 8 days of the last `"Recurrent"` record (record 4). Record 6 is not within 15 days of the `"Case"` and not within 8 days of the last `"Recurrent"` record or its  `"Duplicate"`, and so can now be considered a new `"Case"`. `"Recurrent"` records are indicated in `case_nm` but are considered the same episode as the `"Case"`. This is why records 1 to 5 have the same episode ID.

Note that recurrence periods start from the last record (`"Case"`, `"Duplicate"` or `"Recurrent"`) within the `case_length` or previous reccurence period i.e. the `"Recurrent"` record is the first `"Duplicate"` of the last record within in previous `case_length` or `recurrence_length`.

*Table 1: `"Fixed"` and `"rolling"` episode grouping with their respective `case_lenth` and `recurrence_length`* 
```{r echo=FALSE, fig.height=4, fig.width= 8, warning=FALSE}
library(tidyr)
library(ggplot2)
plot <- bind_rows(
  mutate(rolling_episodes, method="rolling episodes"),
  mutate(fixed_episodes, method="fixed episodes")
  ) %>% 
  mutate(mrk=paste(epid,method,sep = "_"),
         mrk_2=paste(epid,method,case_nm, sep = "_"))

plot <- dplyr::arrange(plot,mrk)
plot$n <- sequence(rle(plot$mrk)$lengths)
plot$N <- rep(rle(plot$mrk)$lengths, rle(plot$mrk)$lengths)

plot <- dplyr::arrange(plot, mrk_2)
plot$n2 <- sequence(rle(plot$mrk_2)$lengths)
plot$N2 <- rep(rle(plot$mrk_2)$lengths, rle(plot$mrk_2)$lengths)

plot <- plot %>%
  mutate(epid_2 = paste(method, ": epid ",epid, sep="" )) %>% 
  select(rid, epid, date, method, epid_2, case_nm, N, n, N2, n2, epi, recur) %>%
  mutate(cd="A", rid=as.character(rid))

lens_plot <- filter(
  plot, 
  ! (case_nm=="Duplicate" & n2==N2 & n!=N)
  )

#lens_plot <- filter(plot, N!=1 & n!=N)
lens_plot <- filter(lens_plot, (case_nm=="Duplicate" & n!=N & n2==N2) | case_nm !="Duplicate")

lens_plot <- mutate(lens_plot,
                    end_l= ifelse(case_nm=="Case", epi, recur),
                    end = date + duration(end_l, "days"))

lens_plot <- select(lens_plot, rid, date, end,
                    epid, epid_2, case_nm, method)

lens_plot <- gather(lens_plot, var, val, -c(rid, epid, epid_2, case_nm, method)) 

ggplot(plot, aes(x=date, y=rid, group=rid, label=case_nm, colour=epid_2)) +
  geom_line(aes(colour=epid_2)) +
  geom_point() +
  geom_text(aes(hjust="right"), nudge_x = -2, nudge_y = .05, show.legend = FALSE) +
  scale_y_discrete("Record ID") +
  scale_x_date("Specimen date", limits = c(dmy("15/03/2019"), dmy("01/07/2019") ), date_breaks = "25 days", date_labels = "%d %b") +
  geom_line(data=lens_plot, aes(x=val, y=rid, group=rid, colour=epid_2), linetype=2) +
  facet_wrap(~method, scales = "free_y") +
  theme(
    strip.background = element_rect(fill="transparent"),
    axis.line = element_line(colour = "black"),
    panel.grid = element_blank(),
    legend.position = "bottom",
    legend.title = element_blank()
  )
```


By default, `episode_group()` will continue checking for `"Recurrent"` records, prolonging the episode until all records have been grouped into episodes. However, you can limit the maximum number of recurrence periods using `rolls_max`.

```{r warning=FALSE, message=FALSE}
infections_3 <- data.frame(
  rid = 1:11,
  date = seq.Date(dmy("01/04/2019"), dmy("11/04/2019"), "1 day"),
  pid = 1, epi = 2, recur =2, stringsAsFactors = FALSE
)

# Infinite recurrence periods per episode (Default)
cbind(
  infections_3,
  episode_group(infections_3, sn = rid, strata = pid, date =date, case_length = epi, 
                episode_type = "rolling", recurrence_length = recur, display = FALSE)
  )

# Maximum of one recurrence period per episode
cbind(
  infections_3,
  episode_group(infections_3, sn = rid, strata = pid, date =date, case_length = epi, 
                episode_type = "rolling", recurrence_length = recur, rolls_max = 1, 
                display = FALSE)
  )

# Maximum of two recurrence periods per episode
cbind(
  infections_3,
  episode_group(infections_3, sn = rid, strata = pid, date =date, case_length = epi, 
                episode_type = "rolling", recurrence_length = recur, rolls_max = 2, 
                display = FALSE)
  )
```

Similarly, you can limit the maximum number of times to creates episodes (per `strata`) using `episode_max`. Once `episode_max` is reached, any record not yet grouped is assigned a unique episode ID and considered a unique `"Case"`. `episode_max` can be used in both `"rolling"` and `"fixed"` episode grouping.

```{r warning=FALSE, message=FALSE}
# Maximum of one episode with one recurrence period
cbind(
  infections_3,
  episode_group(infections_3, sn = rid, strata = pid, date =date,  case_length = epi, 
                episode_type = "rolling", recurrence_length = recur, 
                rolls_max = 1, episodes_max = 1, display = FALSE)
  )

# Maximum of two episodes with one recurrence period
cbind(
  infections_3,
  episode_group(infections_3, sn = rid, strata = pid, date =date,  case_length = epi, 
                episode_type = "rolling", recurrence_length = recur, 
                rolls_max = 1, episodes_max = 2, display = FALSE)
  )

```

<a id="case_assignment"></a> 

## Case assignment
Unless otherwise specified, episode grouping begins at the earliest event/interval and proceeds to the most recent one. Therefore, the earliest event/interval in the `case_length` is considered the `"Case"`. Similarly, the earliest event/interval in the `recurrence_length` is considered the `"Recurrent"` event/interval. You can opt for the opposite behaviour by changing `from_last` to `TRUE`. Doing this will start episode grouping at the most recent event/interval and proceed backwards to the earliest one, thereby making the earliest one the `"Case"`.

```{r warning=FALSE}
# Episode grouping in chronological order
cbind(
  infections,
  episode_group(infections, rid, pid, date, epi, display = FALSE)
  )

# Episode grouping in reverse chronological order
cbind(
  infections,
  episode_group(infections, rid, pid, date, epi, from_last = TRUE, display = FALSE)
  )

```

<a id ="custom_sort"></a>

### User defined case assignment
You can specify a different preference for case assignment from what's been described above. This is using `custom_sort` which is an ordered selection of columns, whose values when sorted in ascending order specifies the required preference. 

As an example, this feature can be used to implement a case definition where *E. coli* urinary tract infections (UTI) are considered precursors to *E. coli* bloodstream infections (BSI). Therefore, episodes need to be created in such a way that; if there are UTI and BSI records within the `case_length`, then episode grouping will start from the UTI record. 

The column(s) used for `custom_sort` can either be `"character"`, `"numeric"` or `"factor"` data types. However, note that each would follow `R` standard sort behaviour. For example, a `factor` will sort on its levels not its descriptive label. See examples of this below.

```{r warning=FALSE}
infections_4 <- mutate(infections, infx=ifelse(row_number() %in% c(2,5), "E. coli UTI", infx))
cbind(
  infections_4,
  episode_group(infections_4, sn=rid, strata=pid, date=date, case_length =epi, 
                custom_sort = infx, display = FALSE)
  )

infections_4 <- mutate(infections_4,infx = factor(infx, levels = c("E. coli UTI","E. coli BSI")))
cbind(
  infections_4,
  episode_group(infections_4, sn=rid, strata=pid, date=date, case_length =epi, custom_sort = infx, display = FALSE)
  )

```

In the second example above, after changing the sort preference using the factor's levels, record 1 (*E. coli* BSI)  and record 2 (*E. coli* UTI) are no longer grouped in the same episode. This is because record 2, is now the reference record, and since record 1 occurred before record 2, it's not considered the same episode. 

This behaviour may suffice depending on your case definition however, you can change this using `bi_direction`. If `TRUE`, records within the `case_length` or `recurrence_length` on either sides of the `"Case"` or `"Recurrent"` events/intervals are grouped together. See the example below where record 1 is now considered a duplicate of record 2 eventhough it occured before record 2.

```{r warning=FALSE}
cbind(
  infections_4,
  episode_group(infections_4, sn=rid, strata=pid, date=date, 
                case_length =epi, custom_sort = infx, bi_direction = TRUE, display = FALSE)
  )

```

A different approach can be to create episodes without `custom_sort` and then recode `case_nm` thereby picking a different record as the "case". This can be the desired approach but it's important to note that this is not the same as using `custom_sort`. This is because using `custom_sort` also determines where episode grouping begins while episode grouping is already complete by the time `case_nm` is recoded. 

As seen below, using the second approach also yields three episodes just as above. However, record 4 belongs to different episodes in both. This is because even though, `case_nm` has been now been recoded such that record 2 is the `"Case"`, episode grouping did not start at record 2.

```{r warning=FALSE}

cbind(
  infections_4,
  episode_group(infections_4, sn=rid, strata=pid, date=date, case_length =epi, 
                display = FALSE)
  ) %>%
  group_by(epid) %>% 
    mutate(
    case_nm = case_when(
      infx=="E. coli UTI" & n()>1 & case_nm == "Duplicate" ~ "Case",
      infx=="E. coli BSI" & n()>1 & case_nm == "Case" ~ "Duplicate",
      TRUE ~ case_nm
    )
  ) %>% 
  ungroup() %>% 
  as.data.frame() %>% 
  select(-starts_with("dup"))

```

<a id="interval_grouping"></a>

## Interval grouping
In addition to grouping events that occured at a point in time (e.g. a day, minute or hour), you can also group time intervals (e.g. a period of days, minutes or hours) into episodes. For the purpose of episode grouping, an interval is a record with a start and end points in times. Each is created as a `lubridate` `interval` and supplied to the `date` argument. 

As an example, you can group periods of hospital admissions into episodes. Each period will be a record with admission and discharge dates as the start and end dates respectively of `lubridate` `interval`. See the example below;

```{r warning=FALSE}
hospital_records <- data.frame(
    rd_id = 1:9,
  admin_dt = c(dmy("01/01/2019"), dmy("01/01/2019"), dmy("10/01/2019"), dmy("05/01/2019"), 
               dmy("05/01/2019"), dmy("07/01/2019"), dmy("04/01/2019"),
               dmy("20/01/2019"), dmy("26/01/2019")),
  discharge_dt = c(dmy("01/01/2019"), dmy("10/01/2019"), dmy("13/01/2019"), dmy("06/01/2019"), 
                   dmy("15/01/2019"), dmy("15/01/2019"), dmy("13/01/2019"), 
                   dmy("30/01/2019"), dmy("31/01/2019"))
  )

hospital_records$epi_len <- 0
hospital_records$admin_period <- interval(hospital_records$admin_dt, hospital_records$discharge_dt)

# grouping admissions events into episodes
cbind(
  hospital_records,
  episode_group(hospital_records, date=admin_dt, sn=rd_id, case_length = epi_len, 
                display = FALSE)
  ) %>% select(-admin_period)

# grouping periods of admissions into episodes
cbind(
  hospital_records,
  episode_group(hospital_records, date=admin_period, sn=rd_id, case_length = epi_len,
                display = FALSE)
  ) %>% select(-admin_dt, -discharge_dt)
```

Time intervals can overlap in different ways, the function allows you choose how this happens using the `overlap_method` argument. The options available are; `"across"`, `"within"`, `"chain"`, `"aligns_start"` and `"aligns_end"`. The default option is to use all methods. The examples and figure below demonstrates their differences.

```{r warning=FALSE}
# overlaping intervals
across <- cbind(
  hospital_records,
  episode_group(hospital_records, date=admin_period, sn=rd_id, case_length = epi_len, 
                overlap_method = "across", display = FALSE)
  ) %>% select(-admin_dt, -discharge_dt)

overlap

# chained intervals
chain <- cbind(
  hospital_records,
  episode_group(hospital_records, date=admin_period, sn=rd_id, case_length = epi_len, 
                overlap_method = "chain", display = FALSE)
  ) %>% select(-admin_dt, -discharge_dt)

chain

# Intervals with aligned end periods
aligns_end <- cbind(
  hospital_records,
  episode_group(hospital_records, date=admin_period, sn=rd_id, case_length = epi_len, 
                overlap_method = "aligns_end", display = FALSE)
  ) %>% select(-admin_dt, -discharge_dt)

aligns_end

# Intervals with aligned start periods
aligns_start <- cbind(
  hospital_records,
  episode_group(hospital_records, date=admin_period, sn=rd_id, case_length = epi_len, 
                overlap_method = "aligns_start", display = FALSE)
  ) %>% select(-admin_dt, -discharge_dt) 

aligns_start

# Intervals occuring completely within others
within <- cbind(
  hospital_records,
  episode_group(hospital_records, date=admin_period, sn=rd_id, case_length = epi_len, 
                overlap_method = "within", display = FALSE)
  ) %>% select(-admin_dt, -discharge_dt)

within

# Intervals occuring completely within others
chain_within <- cbind(
  hospital_records,
  episode_group(hospital_records, date=admin_period, sn=rd_id, case_length = epi_len, 
                overlap_method = c("chain","within"), display = FALSE)
  ) %>% select(-admin_dt, -discharge_dt)

chain_within

```

**Figure 2: Different options for `overlap_method` using a case_length of `"0"` days **
```{r echo=FALSE, fig.height=5, fig.width=8, message=FALSE, warning=FALSE}
plot <- rbind(
  mutate(across, method="across"),
  mutate(chain, method="chain"),
  mutate(aligns_start, method="aligns_start"),
  mutate(aligns_end, method="aligns_end"),
  mutate(within, method="within"), 
  mutate(chain_within, method="chain and within")
  )

plot <- mutate(plot,
  mrk=paste(epid, method,sep="_"),
  admin_dt = dmy(format(int_start(admin_period), "%d/%m/%Y")),
  discharge_dt = dmy(format(int_end(admin_period), "%d/%m/%Y"))
  ) %>% select(-admin_period)

plot <- dplyr::arrange(plot, .data$mrk)
plot$N <- rep(rle(plot$mrk)$lengths, rle(plot$mrk)$lengths)

plot <- plot %>%
  mutate(epid_2 = paste(method, ": epid ",epid, sep="" )) %>% 
  select(rd_id, epid, epid_2, admin_dt, discharge_dt, method, N, epid, case_nm) %>%
  filter(N>1) %>%
  select(rd_id, admin_dt, discharge_dt, method, epid, epid_2, case_nm) %>%
  gather(var, val, -c(rd_id, method, epid, epid_2, case_nm)) %>%
  mutate(
    rd_id = as.character(rd_id), 
    lab =ifelse(case_nm=="Case" & var=="admin_dt", case_nm, ""), 
    method = factor(method, levels = c("across","aligns_start","aligns_end","chain", "within", "chain and within"))
    )

ggplot(plot, aes(x=val, y=rd_id, group=rd_id, label=lab, colour=epid_2)) +
  geom_line(aes(colour=epid_2)) +
  geom_point() +
  geom_text(aes(hjust="right"), nudge_x = -2, nudge_y = .05, show.legend = FALSE) +
  scale_y_discrete("Record ID") +
  scale_x_date("Admitted period", limits = c(dmy("15/12/2018"), dmy("10/02/2019")), date_breaks = "20 days", date_labels = "%d %b") +
  facet_wrap(~method, scales = "free_y") +
  theme(
    strip.background = element_rect(fill="transparent"),
    axis.line = element_line(colour = "black"),
    panel.grid = element_blank(),
    legend.position = "bottom",
    legend.title = element_blank()
  )

```

```{r warning=FALSE, include=FALSE}
# overlaping intervals
hospital_records_2 <- hospital_records
hospital_records_2$epi_len <- 30
hospital_records_2$shift <- ifelse(hospital_records_2$rd_id %in% c(2,8,5,7), 0, 30)
hospital_records_2$admin_period <- int_shift(hospital_records_2$admin_period, duration(hospital_records_2$shift, "days"))

across <- cbind(
  hospital_records_2,
  episode_group(hospital_records_2, date=admin_period, sn=rd_id, case_length = epi_len, 
                overlap_method = "across", display = FALSE)
  ) %>% select(-admin_dt, -discharge_dt)

# chained intervals
chain <- cbind(
  hospital_records_2,
  episode_group(hospital_records_2, date=admin_period, sn=rd_id, case_length = epi_len, 
                overlap_method = "chain", display = FALSE)
  ) %>% select(-admin_dt, -discharge_dt)

# Intervals with aligned end periods
aligns_end <- cbind(
  hospital_records_2,
  episode_group(hospital_records_2, date=admin_period, sn=rd_id, case_length = epi_len, 
                overlap_method = "aligns_end", display = FALSE)
  ) %>% select(-admin_dt, -discharge_dt)

# Intervals with aligned start periods
aligns_start <- cbind(
  hospital_records_2,
  episode_group(hospital_records_2, date=admin_period, sn=rd_id, case_length = epi_len, 
                overlap_method = "aligns_start", display = FALSE)
  ) %>% select(-admin_dt, -discharge_dt)

# Intervals occuring completely within others
within <- cbind(
  hospital_records_2,
  episode_group(hospital_records_2, date=admin_period, sn=rd_id, case_length = epi_len, 
                overlap_method = "within", display = FALSE)
  ) %>% select(-admin_dt, -discharge_dt)

# Chained intervals and those occuring completely within others
chain_within <- cbind(
  hospital_records_2,
  episode_group(hospital_records_2, date=admin_period, sn=rd_id, case_length = epi_len, 
                overlap_method = c("chain","within"), display = FALSE)
  ) %>% select(-admin_dt, -discharge_dt)

# Chained intervals and those with aligned end periods
chain_aligns_end <- cbind(
  hospital_records_2,
  episode_group(hospital_records_2, date=admin_period, sn=rd_id, case_length = epi_len, 
                overlap_method = c("chain","aligns_end"), display = FALSE)
  ) %>%
  select(-admin_dt, -discharge_dt)

# Intervals with aligned start perod or aligned end periods
aligns_start_end <- cbind(
  hospital_records_2,
  episode_group(hospital_records_2, date=admin_period, sn=rd_id, case_length = epi_len, 
                overlap_method = c("aligns_start","aligns_end"), display = FALSE)
  ) %>%
  select(-admin_dt, -discharge_dt)
```

**Figure 3: Different options for `overlap_method` using a case_length of `"30"` days**
```{r echo=FALSE, fig.height=5.5, fig.width=8, message=FALSE, warning=FALSE}

plot <- rbind(
  mutate(across, method="across"),
  mutate(chain, method="chain"),
  mutate(aligns_start, method="aligns_start"),
  mutate(aligns_end, method="aligns_end"),
  mutate(within, method="within"), 
  mutate(chain_within, method="chain and within"), 
  mutate(chain_aligns_end, method="chain and aligns_end")
  #mutate(aligns_start_end, method="aligns_start and aligns_end")
  )

plot <- mutate(plot,
  mrk=paste(epid, method,sep="_"),
  admin_dt = dmy(format(int_start(admin_period), "%d/%m/%Y")),
  discharge_dt = dmy(format(int_end(admin_period), "%d/%m/%Y"))
  ) %>% select(-admin_period)

plot <- dplyr::arrange(plot, .data$mrk)
plot$N <- rep(rle(plot$mrk)$lengths, rle(plot$mrk)$lengths)

plot <- plot %>%
  mutate(epid_2 = paste(method, ": epid ",epid, sep="" )) %>% 
  select(rd_id, epid, epid_2, admin_dt, discharge_dt, method, N, epid, case_nm, epi_len) %>%
  filter(N>1) %>%
  select(rd_id, admin_dt, discharge_dt, method, epid, epid_2, case_nm, epi_len) %>%
  gather(var, val, -c(rd_id, method, epid, epid_2, case_nm, epi_len)) %>%
  mutate(
    rd_id = as.character(rd_id), 
    lab =ifelse(case_nm=="Case" & var=="admin_dt", case_nm, ""), 
    method = factor(method, levels = c("across","aligns_start","aligns_end","chain", "within",
                                       "chain and within", "chain and aligns_end","aligns_start and aligns_end"))
    )

ep_plot <- filter(plot, var=="discharge_dt" & case_nm == "Case") %>% 
  mutate(var="start")

#ep_plot$k <- ifelse(ep_plot$case_nm=="Case", ep_plot$epi_len, ep_plot$recur_len)

ep_plot <- mutate(ep_plot, val= val + duration(epi_len,"days"), var="end") %>% 
  bind_rows(ep_plot)

ggplot(plot, aes(x=val, y=rd_id, group=rd_id, label=lab, colour=epid_2)) +
  geom_line() +
  geom_point() +
  geom_text(aes(hjust="right"), nudge_x = -2, nudge_y = .05, show.legend = FALSE) +
  geom_line(data=ep_plot, aes(x=val, y=rd_id, group=rd_id, colour=epid_2), linetype=2) +
  scale_y_discrete("Record ID") +
  scale_x_date("Admitted period", limits = c(dmy("15/12/2018"), dmy("01/04/2019")), date_breaks = "35 days", date_labels = "%d %b") +
  facet_wrap(~method, scales = "free_y") +
  theme(
    strip.background = element_rect(fill="transparent"),
    axis.line = element_line(colour = "black"),
    panel.grid = element_blank(),
    legend.position = "bottom",
    legend.title = element_blank()
  )

```

You can also create rolling episodes of time intervals. The examples and figure below shows the difference between rolling and fixed episodes of time intervals. 
Notice that for these examples, fixed and rolling episode grouping assings the same episode ID to each record. In example 2, record 8 is after the recurrence period of record 7, and after the `case_length` of record 2 (`"0`). Therefore, it's considered a new `"Case"` and the start of a new episode. In this situation, that's effectively the same as example 1 where there is no recurrence period and a `case_length` of `"0"`. Similarly, in example 4, record 2 has a `case_length` of `"0"` but a recurrence periods long enough to reach records 7 and 8, making them all part of the same episode. This is effectively the same as example 3 where there are no recurrence periods but record 2 has `case_length` long enough to reach records 7 and 8. Note that although these results are the same, the case definitions are not, so results may differ depending on the dataset. However, in general fixed episode grouping takes less time to complete. Therefore, if your case definition does not explicitly require a rolling episode you should use fixed episode grouping. 

```{r warning=FALSE}
fixed_intervals_a <- mutate(hospital_records, recur_len = 0) %>%
  cbind(.,episode_group(., date=admin_period, sn=rd_id, case_length = epi_len,
                        display = FALSE)
  ) %>% select(-admin_dt, -discharge_dt)

fixed_intervals_a


fixed_intervals_b <- mutate(hospital_records, recur_len = 0, epi_len=20) %>%
  cbind(.,episode_group(., date=admin_period, sn=rd_id, case_length = epi_len,
                        display = FALSE)
  ) %>% select(-admin_dt, -discharge_dt)

fixed_intervals_b

rolling_intervals_a <- mutate(hospital_records, recur_len = 4) %>%
  cbind(.,episode_group(., date=admin_period, sn=rd_id, case_length = epi_len, 
                        episode_type = "rolling", recurrence_length = recur_len, 
                        display = FALSE)
  ) %>% select(-admin_dt, -discharge_dt)

rolling_intervals_a

rolling_intervals_b <- mutate(hospital_records, recur_len = 10) %>%
  cbind(.,episode_group(., date=admin_period, sn=rd_id, case_length = epi_len, 
                        episode_type = "rolling", recurrence_length = recur_len,
                        display = FALSE)
  ) %>% select(-admin_dt, -discharge_dt)

rolling_intervals_b

```

**Figure 4: Fixed and rolling episodes of periods of hospital admissions**
```{r echo=FALSE, fig.height=5.5, fig.width=8.5, message=FALSE, warning=FALSE}

plot <- rbind(
  mutate(fixed_intervals_a, method="1. fixed episodes; 0 case_length, 0 recurrence_length"),
  mutate(fixed_intervals_b, method="3. fixed episodes; 30 case_length, 0 recurrence_length"),
  mutate(rolling_intervals_a, method="2. rolling episodes; 0 case_length, recurrence_length 4"),
  mutate(rolling_intervals_b, method="4. rolling episodes; 0 case_length, recurrence_length 10")
  )

plot <- mutate(plot,
  mrk=paste(epid, method,sep="_"),
  admin_dt = dmy(format(int_start(admin_period), "%d/%m/%Y")),
  discharge_dt = dmy(format(int_end(admin_period), "%d/%m/%Y"))
  ) %>% select(-admin_period)

plot <- dplyr::arrange(plot, .data$mrk)
plot$N <- rep(rle(plot$mrk)$lengths, rle(plot$mrk)$lengths)

plot <- plot %>%
  mutate(epid_2 = paste(method, ": epid ",epid, sep="" )) %>% 
  select(rd_id, epid, epid_2, admin_dt, discharge_dt, method, N, epid, case_nm, epi_len, recur_len) %>%
  filter(N>1) %>%
  select(rd_id, admin_dt, discharge_dt, method, epid, epid_2, case_nm, epi_len, recur_len) %>%
  gather(var, val, -c(rd_id, method, epid, epid_2, case_nm, epi_len, recur_len)) %>%
  mutate(
    rd_id = as.character(rd_id), 
    lab =ifelse(case_nm!="Duplicate" & var=="admin_dt", case_nm, "")
    )

ep_plot <- filter(plot, var=="discharge_dt" & 
                    (case_nm %in% c("Case","Recurrent") | (case_nm == "Duplicate" & rd_id ==7))) %>% 
  mutate(var="start")

ep_plot$k <- ifelse(ep_plot$case_nm=="Case", ep_plot$epi_len, ep_plot$recur_len)

ep_plot <- mutate(ep_plot, val= val + duration(k,"days"), var="end") %>% 
  bind_rows(ep_plot)

ggplot(plot, aes(x=val, y=rd_id, group=rd_id, label=lab, colour=epid_2)) +
  geom_line() +
  geom_point() +
  geom_text(aes(hjust="right"), nudge_x = -2, nudge_y = .05, show.legend = FALSE) +
  geom_line(data=ep_plot, aes(x=val, y=rd_id, group=rd_id, colour=epid_2), linetype=2) +
  scale_y_discrete("Record ID") +
  scale_x_date("Admitted period", limits = c(dmy("15/12/2018"), dmy("10/02/2019")), date_breaks = "10 days", date_labels = "%d %b") +
  facet_wrap(~method, scales = "free_y", nrow = 2) +
  guides(colour= guide_legend(ncol = 2)) +
  theme(
    strip.background = element_rect(fill="transparent"),
    axis.line = element_line(colour = "black"),
    panel.grid = element_blank(),
    legend.position = "bottom",
    legend.title = element_blank()
  )

```

<a id="stratified_grouping"></a>

## Stratified episode grouping
Episode grouping can be done separately by different type of records (`strata`). Examples of a `strata` could be patient IDs, type of pathogen, source of infection or a combination of these parameters. Episodes will not overlap across different `strata` but can have different `case_length` and `recurrence_lenght`.

To implement this, assign the column name(s) of the record type identifier(s) to the `strata` argument. `record_group()` is useful for creating a group identifier which can be assigned to the `strata` argument. See [record group](record_group.html) for further details.

As an example, using the `infections_4` dataset, a case definition may specify the following;

- UTI and BSI records are considered different episodes regardless of when they occur. 
- UTI has a `case_length` of 7 days and recurrence period of 30 days
- BSI has a `case_length` of 14 days and no recurrence period

In the example below, adding `infx` to the `strata` argument means that `"E. coli UTI"` episodes will not overlap with `"E. coli BSI"` records. Furthermore, the `case_length` and `recurrence_length` for each will be different as specified in `epi` and `recur` columns respectively 
```{r warning=FALSE}
infections_5 <- mutate(infections_4, 
                       epi = ifelse(infx=="E. coli UTI", 7, 14),
                       recur = ifelse(infx=="E. coli UTI", 30, 0))
cbind(
  infections_5,
  episode_group(infections_5, sn=rid, strata=c(pid, infx), date=date, 
                case_length =epi, episode_type = "rolling", recurrence_length = recur,
                display = FALSE)
  )

```

<a id="sub_strata"></a>

### Sub-strata
If `case_length` or `recurrence_length` is unique to a `strata`, every episode in that `strata` will have the same `case_length`. However, a sub-strata is created when records within a `strata` have different `case_length` or `recurrence_length`. For example, a different case definition may specify that;

- UTI and BSI records are different episodes regardless of when they occur. 
- UTI have a `case_length` of 7 days and recurrence period of 30 days
- BSI have a `case_length` of 14 days if not treated, **OR** `case_length` of 4 days if treated, and no recurence period in both situations
- Respiratory tract infections (RTI) have a `case_length` of 28 days and recurrence period of 5 days

In this example, whether or not the infection is treated should be considered the sub-strata, and the source of infection considered the `strata`.

```{r warning=FALSE}
infections_5 <- data.frame(
  rid = 1:11,
  date = seq.Date(dmy("01/04/2019"), dmy("21/05/2019"), "5 day"),
  pid = 1,
  organism = rep("E. coli",11), 
  source =c(rep("UTI",2), rep("BSI",3), rep("RTI",2), rep("BSI",2), rep("UTI",2)), 
  treated = c("-","-","Y","N","Y","Y","N","Y","N","N","N"),
  stringsAsFactors = FALSE
)

infections_5 <- mutate(infections_5,
                       epi = case_when(
                         source == "UTI" ~ 7,
                         source == "BSI" & treated == "Y" ~ 4,
                         source == "BSI" & treated %in% c("N","-") ~ 14,
                         source == "RTI" ~ 28
                         ),
                       recur = case_when(
                         source == "UTI" ~ 30,
                         source == "BSI" & treated == "Y" ~ 0,
                         source == "BSI" & treated %in% c("N","-") ~ 0,
                         source == "RTI" ~ 5
                         )
                       )

cbind(
  infections_5,
  episode_group(infections_5, sn=rid, strata=c(pid, organism, source), date=date, 
                case_length =epi, episode_type = "rolling", recurrence_length = recur,
                display = FALSE)
  )

```

There are a few things to note with stratified grouping;

- Unless required, `case_length` and `recurrence_length` should be consistent across each `strata` otherwise, you'll inadvertently create a sub-strata
- The behaviour of `episode_grouping()` with and without a sub-strata is different and could lead to different results
- Using sub-strata is not the same as adding that sub-strata to the `strata` argument. In the example above, adding `treated` to `strata` will group treated infections separately from untreated infections. While this could be the desired outcome depending on your case definition, the case definition above did not required treated and untreated infections to be grouped separately, only that the treated infections last longer. The example below demonstrates this difference;

```{r warning=FALSE}

cbind(
  infections_5,
  episode_group(infections_5, sn=rid, strata=c(pid, organism, source), date=date, 
                case_length =epi, episode_type = "rolling", recurrence_length = recur,
                display = FALSE)
  )

```

Stratified episode grouping will produce the same results as when you subset the dataset by `strata` and use `episode_group()` on each with same arguments as required. However, using stratified episode allows you to avoide repeat analysis using the same case definition.

<a id="tips"></a>

## Useful ways of using episode_group 
### Episode grouping across other units of time
In the examples above, the unit for episode length (`episode_unit`) was in "days". However, episode grouping can be done the same units supported `lubridate duration()` function. Below is an example of episode grouping by the hour.

```{r warning=FALSE, message=FALSE}
hourly_dataset <- data.frame(
  rid = 1:13,
  datetime = seq.POSIXt(dmy_hms("01/04/2019 00:00:00"), dmy_hms("01/04/2019 24:00:00"), "120 min"),
  category = c(rep(c("GP1","GP2"), 4), rep("GP3",5)) , epi =5, recur =9, 
  stringsAsFactors = FALSE
)

cbind(
  hourly_dataset,
  episode_group(hourly_dataset, rid, category, datetime, epi, episode_type = "rolling", episode_unit = "hours", recurrence_length = recur, group_stats = TRUE)
  )
```

### Limit episode grouping to a subset of the dataframe
If there is a subset which you do not wish to group into episodes, you can separate the dataframe and use `episode_group()` on only the desired subset. Then join the subsets back to form the original dataframe. However, a faster alternative could be to a `strata` with missing values for the subsets you need to exclude from episode grouping. Doing this will skip the specified records from episode grouping and assign each a episode unique IDs.

For example, with the `hourly_dataset`, you can decide to exclude `"GP1"` and `"GP2"` records from episode grouping as shown below;  

```{r warning=FALSE, message=FALSE}
head(hourly_dataset, 10) %>% 
  mutate(subset = ifelse(category!="GP3", NA, "group")) %>% 
  cbind(.,episode_group(., rid, subset, datetime, epi, episode_type = "rolling", episode_unit = "hours", 
                        recurrence_length = recur, display = TRUE, group_stats = TRUE))
```

Note that using a `case_length` and `recurrence_length` of `"0"` will also have the same effect but will take more time, because each record is still being checked before but since there is no `case_length` and `recurrence_length`, each is assigned a unique episode ID. See the difference below;

```{r warning=FALSE, message=FALSE}
head(hourly_dataset, 10) %>% 
  mutate(epi = ifelse(category!="GP3", 0, epi), recur = ifelse(category!="GP3",0,recur)) %>% 
  cbind(.,episode_group(., rid, category, datetime, epi, episode_type = "rolling", episode_unit = "hours", recurrence_length = recur, display = TRUE))
```
 
